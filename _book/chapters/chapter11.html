
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>第11章：AI加速器基础 · FPGA原理与AI加速应用教程</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="FPGA教程团队">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter12.html" />
    
    
    <link rel="prev" href="chapter10.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                        <b>1.1.</b>
                    
                    介绍
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第一部分：FPGA基础架构</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="chapter1.html">
            
                <a href="chapter1.html">
            
                    
                        <b>2.1.</b>
                    
                    第1章：FPGA基础架构与工作原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="chapter2.html">
            
                <a href="chapter2.html">
            
                    
                        <b>2.2.</b>
                    
                    第2章：HDL设计基础与方法学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="chapter3.html">
            
                <a href="chapter3.html">
            
                    
                        <b>2.3.</b>
                    
                    第3章：时序、时钟与同步
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="chapter4.html">
            
                <a href="chapter4.html">
            
                    
                        <b>2.4.</b>
                    
                    第4章：存储器系统与接口设计
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第二部分：高级设计技术</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="chapter5.html">
            
                <a href="chapter5.html">
            
                    
                        <b>3.1.</b>
                    
                    第5章：高速I/O与通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="chapter6.html">
            
                <a href="chapter6.html">
            
                    
                        <b>3.2.</b>
                    
                    第6章：DSP与算术优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="chapter7.html">
            
                <a href="chapter7.html">
            
                    
                        <b>3.3.</b>
                    
                    第7章：HLS与C到硬件综合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="chapter8.html">
            
                <a href="chapter8.html">
            
                    
                        <b>3.4.</b>
                    
                    第8章：函数式HDL之Haskell/Clash
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="chapter9.html">
            
                <a href="chapter9.html">
            
                    
                        <b>3.5.</b>
                    
                    第9章：OCaml/Hardcaml硬件设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="chapter10.html">
            
                <a href="chapter10.html">
            
                    
                        <b>3.6.</b>
                    
                    第10章：零知识证明加速器
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第三部分：AI加速实战</li>
        
        
    
        <li class="chapter active" data-level="4.1" data-path="chapter11.html">
            
                <a href="chapter11.html">
            
                    
                        <b>4.1.</b>
                    
                    第11章：AI加速器基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="chapter12.html">
            
                <a href="chapter12.html">
            
                    
                        <b>4.2.</b>
                    
                    第12章：LLM推理加速
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="chapter13.html">
            
                <a href="chapter13.html">
            
                    
                        <b>4.3.</b>
                    
                    第13章：视觉与多模态处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="chapter14.html">
            
                <a href="chapter14.html">
            
                    
                        <b>4.4.</b>
                    
                    第14章：LLM服务基础设施
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="chapter15.html">
            
                <a href="chapter15.html">
            
                    
                        <b>4.5.</b>
                    
                    第15章：机器人运动控制与FPGA
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.6" data-path="chapter16.html">
            
                <a href="chapter16.html">
            
                    
                        <b>4.6.</b>
                    
                    第16章：激光雷达信号处理与FPGA
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.7" data-path="chapter17.html">
            
                <a href="chapter17.html">
            
                    
                        <b>4.7.</b>
                    
                    第17章：毫米波雷达与FPGA
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第四部分：高级优化与扩展</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="chapter18.html">
            
                <a href="chapter18.html">
            
                    
                        <b>5.1.</b>
                    
                    第18章：性能分析与优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="chapter19.html">
            
                <a href="chapter19.html">
            
                    
                        <b>5.2.</b>
                    
                    第19章：功耗优化技术
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3" data-path="chapter20.html">
            
                <a href="chapter20.html">
            
                    
                        <b>5.3.</b>
                    
                    第20章：多FPGA系统与扩展
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.4" data-path="chapter21.html">
            
                <a href="chapter21.html">
            
                    
                        <b>5.4.</b>
                    
                    第21章：可靠性与容错设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.5" data-path="chapter22.html">
            
                <a href="chapter22.html">
            
                    
                        <b>5.5.</b>
                    
                    第22章：未来趋势与新兴技术
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../docs/DEPLOY_README.md">
            
                <span>
            
                    
                        <b>6.1.</b>
                    
                    部署指南
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2" data-path="../docs/GITBOOK_SETUP.md">
            
                <span>
            
                    
                        <b>6.2.</b>
                    
                    安装说明
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3" data-path="../docs/CONVERSION_SUMMARY.md">
            
                <span>
            
                    
                        <b>6.3.</b>
                    
                    转换总结
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >第11章：AI加速器基础</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="&#x7B2C;&#x5341;&#x4E00;&#x7AE0;&#xFF1A;ai&#x52A0;&#x901F;&#x5668;&#x57FA;&#x7840;">&#x7B2C;&#x5341;&#x4E00;&#x7AE0;&#xFF1A;AI&#x52A0;&#x901F;&#x5668;&#x57FA;&#x7840;</h1>
<p>&#x672C;&#x7AE0;&#x6DF1;&#x5165;&#x63A2;&#x8BA8;FPGA&#x5B9E;&#x73B0;AI&#x52A0;&#x901F;&#x5668;&#x7684;&#x57FA;&#x7840;&#x67B6;&#x6784;&#x548C;&#x8BBE;&#x8BA1;&#x65B9;&#x6CD5;&#x3002;&#x6211;&#x4EEC;&#x5C06;&#x4ECE;&#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x7684;&#x8BA1;&#x7B97;&#x7279;&#x6027;&#x5206;&#x6790;&#x51FA;&#x53D1;&#xFF0C;&#x7406;&#x89E3;&#x5982;&#x4F55;&#x5C06;&#x7B97;&#x6CD5;&#x6620;&#x5C04;&#x5230;&#x786C;&#x4EF6;&#x67B6;&#x6784;&#xFF0C;&#x91CD;&#x70B9;&#x5173;&#x6CE8;&#x91CF;&#x5316;&#x6280;&#x672F;&#x3001;&#x5E76;&#x884C;&#x8BA1;&#x7B97;&#x6A21;&#x5F0F;&#x4EE5;&#x53CA;&#x7247;&#x4E0A;&#x4E92;&#x8054;&#x8BBE;&#x8BA1;&#x3002;&#x901A;&#x8FC7;&#x5BF9;&#x6BD4;&#x8109;&#x52A8;&#x9635;&#x5217;&#x548C;&#x6570;&#x636E;&#x6D41;&#x4E24;&#x79CD;&#x4E3B;&#x6D41;&#x67B6;&#x6784;&#xFF0C;&#x60A8;&#x5C06;&#x638C;&#x63E1;&#x9009;&#x62E9;&#x5408;&#x9002;&#x52A0;&#x901F;&#x5668;&#x67B6;&#x6784;&#x7684;&#x51B3;&#x7B56;&#x4F9D;&#x636E;&#x3002;&#x672C;&#x7AE0;&#x8FD8;&#x5C06;&#x5BF9;&#x6BD4;FPGA&#x3001;GPU&#x548C;TPU&#x5728;AI&#x63A8;&#x7406;&#x4E2D;&#x7684;&#x4F18;&#x52A3;&#x52BF;&#xFF0C;&#x4E3A;&#x5B9E;&#x9645;&#x9879;&#x76EE;&#x7684;&#x5E73;&#x53F0;&#x9009;&#x62E9;&#x63D0;&#x4F9B;&#x6307;&#x5BFC;&#x3002;</p>
<h2 id="111-&#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x8BA1;&#x7B97;&#x7279;&#x5F81;&#x5206;&#x6790;">11.1 &#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x8BA1;&#x7B97;&#x7279;&#x5F81;&#x5206;&#x6790;</h2>
<h3 id="1111-&#x8BA1;&#x7B97;&#x5BC6;&#x96C6;&#x578B;&#x7279;&#x5F81;">11.1.1 &#x8BA1;&#x7B97;&#x5BC6;&#x96C6;&#x578B;&#x7279;&#x5F81;</h3>
<p>&#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x7684;&#x6838;&#x5FC3;&#x8BA1;&#x7B97;&#x53EF;&#x4EE5;&#x5F52;&#x7EB3;&#x4E3A;&#x51E0;&#x79CD;&#x57FA;&#x672C;&#x64CD;&#x4F5C;&#xFF1A;</p>
<pre><code class="lang-systemverilog">// &#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x57FA;&#x672C;&#x8FD0;&#x7B97;&#x5355;&#x5143;
module nn_compute_unit #(
    parameter DATA_WIDTH = 16,
    parameter VECTOR_SIZE = 64
) (
    input  logic                    clk,
    input  logic                    rst_n,

    // &#x8F93;&#x5165;&#x7279;&#x5F81;&#x548C;&#x6743;&#x91CD;
    input  logic [DATA_WIDTH-1:0]   feature_in[VECTOR_SIZE],
    input  logic [DATA_WIDTH-1:0]   weight_in[VECTOR_SIZE],
    input  logic [DATA_WIDTH-1:0]   bias_in,

    // &#x8F93;&#x51FA;&#x7ED3;&#x679C;
    output logic [DATA_WIDTH*2-1:0] acc_out,
    output logic                    valid_out
);
    // MAC (Multiply-Accumulate) &#x9635;&#x5217;
    logic [DATA_WIDTH*2-1:0] products[VECTOR_SIZE];
    logic [DATA_WIDTH*2-1:0] acc_reg;

    // &#x5E76;&#x884C;&#x4E58;&#x6CD5;
    generate
        for (genvar i = 0; i &lt; VECTOR_SIZE; i++) begin : gen_mult
            assign products[i] = feature_in[i] * weight_in[i];
        end
    endgenerate

    // &#x7D2F;&#x52A0;&#x6811;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            acc_reg &lt;= &apos;0;
        end else begin
            acc_reg &lt;= bias_in;
            for (int i = 0; i &lt; VECTOR_SIZE; i++) begin
                acc_reg &lt;= acc_reg + products[i];
            end
        end
    end
endmodule
</code></pre>
<p><strong>&#x8BA1;&#x7B97;&#x7279;&#x5F81;&#x5206;&#x6790;&#xFF1A;</strong></p>
<ol>
<li><p><strong>&#x77E9;&#x9635;&#x4E58;&#x6CD5;&#x5BC6;&#x96C6;</strong></p>
<ul>
<li>&#x5377;&#x79EF;&#x5C42;&#xFF1A;90%+ &#x8BA1;&#x7B97;&#x91CF;</li>
<li>&#x5168;&#x8FDE;&#x63A5;&#x5C42;&#xFF1A;&#x5927;&#x91CF;&#x77E9;&#x9635;-&#x5411;&#x91CF;&#x4E58;&#x6CD5;</li>
<li>&#x6CE8;&#x610F;&#x529B;&#x673A;&#x5236;&#xFF1A;&#x77E9;&#x9635;-&#x77E9;&#x9635;&#x4E58;&#x6CD5;</li>
</ul>
</li>
<li><p><strong>&#x6570;&#x636E;&#x91CD;&#x7528;&#x6A21;&#x5F0F;</strong></p>
<ul>
<li>&#x6743;&#x91CD;&#x91CD;&#x7528;&#xFF1A;&#x6279;&#x5904;&#x7406;&#x63A8;&#x7406;</li>
<li>&#x8F93;&#x5165;&#x91CD;&#x7528;&#xFF1A;&#x5377;&#x79EF;&#x6ED1;&#x7A97;</li>
<li>&#x90E8;&#x5206;&#x548C;&#x91CD;&#x7528;&#xFF1A;&#x5927;&#x77E9;&#x9635;&#x5206;&#x5757;</li>
</ul>
</li>
<li><p><strong>&#x5185;&#x5B58;&#x8BBF;&#x95EE;&#x6A21;&#x5F0F;</strong></p>
<ul>
<li>&#x987A;&#x5E8F;&#x8BBF;&#x95EE;&#xFF1A;&#x5229;&#x4E8E;&#x7A81;&#x53D1;&#x4F20;&#x8F93;</li>
<li>&#x53EF;&#x9884;&#x6D4B;&#x6027;&#xFF1A;&#x4FBF;&#x4E8E;&#x9884;&#x53D6;</li>
<li>&#x5C40;&#x90E8;&#x6027;&#xFF1A;&#x9002;&#x5408;&#x7F13;&#x5B58;&#x8BBE;&#x8BA1;</li>
</ul>
</li>
</ol>
<h3 id="1112-&#x5E76;&#x884C;&#x5316;&#x673A;&#x4F1A;">11.1.2 &#x5E76;&#x884C;&#x5316;&#x673A;&#x4F1A;</h3>
<pre><code class="lang-systemverilog">// &#x591A;&#x7EF4;&#x5E76;&#x884C;&#x5316;&#x793A;&#x4F8B;
module parallel_conv_engine #(
    parameter IN_CHANNELS = 64,
    parameter OUT_CHANNELS = 128,
    parameter KERNEL_SIZE = 3,
    parameter PARALLEL_IN = 8,    // &#x8F93;&#x5165;&#x901A;&#x9053;&#x5E76;&#x884C;&#x5EA6;
    parameter PARALLEL_OUT = 16   // &#x8F93;&#x51FA;&#x901A;&#x9053;&#x5E76;&#x884C;&#x5EA6;
) (
    input  logic clk,
    input  logic rst_n,

    // &#x8F93;&#x5165;&#x7279;&#x5F81;&#x56FE;&#x5757;
    input  logic [15:0] ifmap[PARALLEL_IN][KERNEL_SIZE][KERNEL_SIZE],
    // &#x6743;&#x91CD;
    input  logic [15:0] weights[PARALLEL_OUT][PARALLEL_IN][KERNEL_SIZE][KERNEL_SIZE],
    // &#x8F93;&#x51FA;&#x7279;&#x5F81;&#x56FE;
    output logic [31:0] ofmap[PARALLEL_OUT],
    output logic        valid
);
    // PE (Processing Element) &#x9635;&#x5217;
    logic [31:0] partial_sums[PARALLEL_OUT][PARALLEL_IN];

    // &#x5B9E;&#x4F8B;&#x5316;PE&#x9635;&#x5217;
    generate
        for (genvar oc = 0; oc &lt; PARALLEL_OUT; oc++) begin : gen_oc
            for (genvar ic = 0; ic &lt; PARALLEL_IN; ic++) begin : gen_ic
                pe_3x3 pe_inst (
                    .clk(clk),
                    .ifmap(ifmap[ic]),
                    .weight(weights[oc][ic]),
                    .psum_out(partial_sums[oc][ic])
                );
            end
        end
    endgenerate

    // &#x89C4;&#x7EA6;&#x6811;
    generate
        for (genvar oc = 0; oc &lt; PARALLEL_OUT; oc++) begin : gen_reduce
            always_ff @(posedge clk) begin
                ofmap[oc] &lt;= &apos;0;
                for (int ic = 0; ic &lt; PARALLEL_IN; ic++) begin
                    ofmap[oc] &lt;= ofmap[oc] + partial_sums[oc][ic];
                end
            end
        end
    endgenerate
endmodule
</code></pre>
<p><strong>&#x5E76;&#x884C;&#x5316;&#x7EF4;&#x5EA6;&#xFF1A;</strong></p>
<ul>
<li>&#x6279;&#x6B21;&#x5E76;&#x884C;&#xFF08;N&#x7EF4;&#xFF09;</li>
<li>&#x901A;&#x9053;&#x5E76;&#x884C;&#xFF08;C&#x7EF4;&#xFF09;</li>
<li>&#x7A7A;&#x95F4;&#x5E76;&#x884C;&#xFF08;H/W&#x7EF4;&#xFF09;</li>
<li>&#x6838;&#x5E76;&#x884C;&#xFF08;K&#x7EF4;&#xFF09;</li>
</ul>
<h3 id="1113-&#x6570;&#x636E;&#x6D41;&#x5206;&#x6790;">11.1.3 &#x6570;&#x636E;&#x6D41;&#x5206;&#x6790;</h3>
<pre><code class="lang-systemverilog">// &#x6570;&#x636E;&#x6D41;&#x8C03;&#x5EA6;&#x5668;
module dataflow_scheduler #(
    parameter TILE_SIZE = 16,
    parameter BUFFER_DEPTH = 1024
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x5916;&#x90E8;&#x5B58;&#x50A8;&#x63A5;&#x53E3;
    axi_if.master       ddr_if,

    // &#x8BA1;&#x7B97;&#x5355;&#x5143;&#x63A5;&#x53E3;
    output logic [15:0] tile_a[TILE_SIZE][TILE_SIZE],
    output logic [15:0] tile_b[TILE_SIZE][TILE_SIZE],
    input  logic [31:0] tile_c[TILE_SIZE][TILE_SIZE],

    // &#x63A7;&#x5236;&#x4FE1;&#x53F7;
    input  logic        start,
    output logic        done
);
    // &#x53CC;&#x7F13;&#x51B2;&#x8BBE;&#x8BA1;
    logic [15:0] buffer_a[2][TILE_SIZE][TILE_SIZE];
    logic [15:0] buffer_b[2][TILE_SIZE][TILE_SIZE];
    logic        buffer_sel;

    // &#x72B6;&#x6001;&#x673A;
    enum logic [2:0] {
        IDLE,
        LOAD_A,
        LOAD_B,
        COMPUTE,
        STORE_C
    } state;

    // &#x6D41;&#x6C34;&#x7EBF;&#x63A7;&#x5236;
    always_ff @(posedge clk) begin
        case (state)
            LOAD_A: begin
                // &#x4ECE;DDR&#x52A0;&#x8F7D;tile A&#x5230;buffer[!buffer_sel]
                // &#x540C;&#x65F6;&#x8BA1;&#x7B97;&#x4F7F;&#x7528;buffer[buffer_sel]
            end

            COMPUTE: begin
                // &#x89E6;&#x53D1;&#x77E9;&#x9635;&#x4E58;&#x6CD5;
                // &#x9884;&#x53D6;&#x4E0B;&#x4E00;&#x4E2A;tile
            end
        endcase
    end
endmodule
</code></pre>
<h2 id="112-&#x91CF;&#x5316;&#x4E0E;&#x5B9A;&#x70B9;&#x63A8;&#x7406;">11.2 &#x91CF;&#x5316;&#x4E0E;&#x5B9A;&#x70B9;&#x63A8;&#x7406;</h2>
<h3 id="1121-&#x91CF;&#x5316;&#x57FA;&#x7840;&#x7406;&#x8BBA;">11.2.1 &#x91CF;&#x5316;&#x57FA;&#x7840;&#x7406;&#x8BBA;</h3>
<p>&#x91CF;&#x5316;&#x662F;&#x5C06;&#x6D6E;&#x70B9;&#x6570;&#x6620;&#x5C04;&#x5230;&#x4F4E;&#x4F4D;&#x5BBD;&#x5B9A;&#x70B9;&#x6570;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x5BF9;FPGA&#x52A0;&#x901F;&#x81F3;&#x5173;&#x91CD;&#x8981;&#xFF1A;</p>
<pre><code class="lang-systemverilog">// &#x91CF;&#x5316;&#x5668;&#x6A21;&#x5757;
module quantizer #(
    parameter FLOAT_WIDTH = 32,
    parameter FIXED_WIDTH = 8,
    parameter FRAC_BITS = 4      // &#x5C0F;&#x6570;&#x4F4D;&#x6570;
) (
    input  logic [FLOAT_WIDTH-1:0] float_in,
    input  logic [31:0]            scale,
    input  logic [7:0]             zero_point,

    output logic [FIXED_WIDTH-1:0] fixed_out,
    output logic                   overflow
);
    // &#x91CF;&#x5316;&#x516C;&#x5F0F;&#xFF1A;q = round(x/scale) + zero_point
    logic [63:0] scaled_val;
    logic [31:0] rounded_val;

    // &#x7F29;&#x653E;
    assign scaled_val = float_in * (1 &lt;&lt; FRAC_BITS) / scale;

    // &#x56DB;&#x820D;&#x4E94;&#x5165;
    assign rounded_val = scaled_val + (1 &lt;&lt; (FRAC_BITS-1));

    // &#x9971;&#x548C;&#x5904;&#x7406;
    always_comb begin
        if (rounded_val &gt; ((1 &lt;&lt; FIXED_WIDTH) - 1)) begin
            fixed_out = (1 &lt;&lt; FIXED_WIDTH) - 1;
            overflow = 1&apos;b1;
        end else begin
            fixed_out = rounded_val[FIXED_WIDTH-1:0] + zero_point;
            overflow = 1&apos;b0;
        end
    end
endmodule
</code></pre>
<p><strong>&#x91CF;&#x5316;&#x65B9;&#x6848;&#x5BF9;&#x6BD4;&#xFF1A;</strong></p>
<ol>
<li><p><strong>&#x5747;&#x5300;&#x91CF;&#x5316;</strong></p>
<ul>
<li>INT8&#xFF1A;&#x63A8;&#x7406;&#x7CBE;&#x5EA6;&#x635F;&#x5931;&lt;1%</li>
<li>INT4&#xFF1A;&#x9700;&#x8981;&#x611F;&#x77E5;&#x8BAD;&#x7EC3;</li>
<li>&#x4E8C;&#x503C;/&#x4E09;&#x503C;&#xFF1A;&#x6781;&#x9650;&#x538B;&#x7F29;</li>
</ul>
</li>
<li><p><strong>&#x975E;&#x5747;&#x5300;&#x91CF;&#x5316;</strong></p>
<ul>
<li>&#x5BF9;&#x6570;&#x91CF;&#x5316;</li>
<li>&#x81EA;&#x9002;&#x5E94;&#x91CF;&#x5316;</li>
<li>&#x6DF7;&#x5408;&#x7CBE;&#x5EA6;</li>
</ul>
</li>
</ol>
<h3 id="1122-&#x5B9A;&#x70B9;&#x8FD0;&#x7B97;&#x5355;&#x5143;&#x8BBE;&#x8BA1;">11.2.2 &#x5B9A;&#x70B9;&#x8FD0;&#x7B97;&#x5355;&#x5143;&#x8BBE;&#x8BA1;</h3>
<pre><code class="lang-systemverilog">// &#x5B9A;&#x70B9;MAC&#x5355;&#x5143;
module fixed_point_mac #(
    parameter IN_WIDTH = 8,
    parameter WEIGHT_WIDTH = 8,
    parameter ACC_WIDTH = 32
) (
    input  logic                    clk,
    input  logic                    rst_n,
    input  logic                    en,

    input  logic signed [IN_WIDTH-1:0]     input_data,
    input  logic signed [WEIGHT_WIDTH-1:0] weight,
    input  logic signed [ACC_WIDTH-1:0]    bias,

    output logic signed [ACC_WIDTH-1:0]    acc_out
);
    // &#x4E2D;&#x95F4;&#x7ED3;&#x679C;
    logic signed [IN_WIDTH+WEIGHT_WIDTH-1:0] product;
    logic signed [ACC_WIDTH-1:0]             acc_reg;

    // &#x4E58;&#x6CD5;&#x5668;&#xFF08;&#x4F7F;&#x7528;DSP&#xFF09;
    always_ff @(posedge clk) begin
        if (!rst_n)
            product &lt;= &apos;0;
        else if (en)
            product &lt;= input_data * weight;
    end

    // &#x7D2F;&#x52A0;&#x5668;
    always_ff @(posedge clk) begin
        if (!rst_n)
            acc_reg &lt;= &apos;0;
        else if (en) begin
            if (bias != &apos;0)
                acc_reg &lt;= bias + product;
            else
                acc_reg &lt;= acc_reg + product;
        end
    end

    assign acc_out = acc_reg;
endmodule
</code></pre>
<h3 id="1123-&#x52A8;&#x6001;&#x91CF;&#x5316;&#x7B56;&#x7565;">11.2.3 &#x52A8;&#x6001;&#x91CF;&#x5316;&#x7B56;&#x7565;</h3>
<pre><code class="lang-systemverilog">// &#x52A8;&#x6001;&#x91CF;&#x5316;&#x63A7;&#x5236;&#x5668;
module dynamic_quantization_controller (
    input  logic        clk,
    input  logic        rst_n,

    // &#x7EDF;&#x8BA1;&#x8F93;&#x5165;
    input  logic [31:0] activation_max,
    input  logic [31:0] activation_min,
    input  logic        stats_valid,

    // &#x91CF;&#x5316;&#x53C2;&#x6570;&#x8F93;&#x51FA;
    output logic [7:0]  scale_factor,
    output logic [7:0]  zero_point,
    output logic        params_valid
);
    // &#x6ED1;&#x52A8;&#x7A97;&#x53E3;&#x7EDF;&#x8BA1;
    logic [31:0] max_history[8];
    logic [31:0] min_history[8];
    logic [2:0]  hist_ptr;

    // EMA (&#x6307;&#x6570;&#x79FB;&#x52A8;&#x5E73;&#x5747;)
    logic [31:0] ema_max, ema_min;

    always_ff @(posedge clk) begin
        if (stats_valid) begin
            // &#x66F4;&#x65B0;&#x5386;&#x53F2;
            max_history[hist_ptr] &lt;= activation_max;
            min_history[hist_ptr] &lt;= activation_min;
            hist_ptr &lt;= hist_ptr + 1;

            // &#x8BA1;&#x7B97;EMA
            ema_max &lt;= (ema_max * 7 + activation_max) &gt;&gt; 3;
            ema_min &lt;= (ema_min * 7 + activation_min) &gt;&gt; 3;
        end
    end

    // &#x8BA1;&#x7B97;&#x91CF;&#x5316;&#x53C2;&#x6570;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            scale_factor &lt;= 8&apos;d128;
            zero_point &lt;= 8&apos;d128;
        end else begin
            // &#x8BA1;&#x7B97;scale&#x548C;zero_point
            scale_factor &lt;= (ema_max - ema_min) &gt;&gt; 8;
            zero_point &lt;= -ema_min / scale_factor;
        end
    end
endmodule
</code></pre>
<h3 id="1124-&#x6DF7;&#x5408;&#x7CBE;&#x5EA6;&#x63A8;&#x7406;">11.2.4 &#x6DF7;&#x5408;&#x7CBE;&#x5EA6;&#x63A8;&#x7406;</h3>
<pre><code class="lang-systemverilog">// &#x6DF7;&#x5408;&#x7CBE;&#x5EA6;&#x8BA1;&#x7B97;&#x5355;&#x5143;
module mixed_precision_pe #(
    parameter MAX_WIDTH = 16
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x7CBE;&#x5EA6;&#x914D;&#x7F6E;
    input  logic [1:0]  precision_mode, // 00:INT4, 01:INT8, 10:INT16

    // &#x7075;&#x6D3B;&#x4F4D;&#x5BBD;&#x8F93;&#x5165;
    input  logic [MAX_WIDTH-1:0] a_in,
    input  logic [MAX_WIDTH-1:0] b_in,

    // &#x8F93;&#x51FA;
    output logic [MAX_WIDTH*2-1:0] result
);
    // &#x4E0D;&#x540C;&#x7CBE;&#x5EA6;&#x7684;&#x8BA1;&#x7B97;&#x8DEF;&#x5F84;
    logic [7:0]  a_int4, b_int4;
    logic [15:0] a_int8, b_int8;
    logic [31:0] result_int4, result_int8, result_int16;

    // &#x7CBE;&#x5EA6;&#x8F6C;&#x6362;
    assign a_int4 = a_in[3:0];
    assign b_int4 = b_in[3:0];
    assign a_int8 = a_in[7:0];
    assign b_int8 = b_in[7:0];

    // &#x5E76;&#x884C;&#x8BA1;&#x7B97;&#x4E0D;&#x540C;&#x7CBE;&#x5EA6;
    always_ff @(posedge clk) begin
        result_int4 &lt;= a_int4 * b_int4;
        result_int8 &lt;= a_int8 * b_int8;
        result_int16 &lt;= a_in * b_in;
    end

    // &#x8F93;&#x51FA;&#x9009;&#x62E9;
    always_comb begin
        case (precision_mode)
            2&apos;b00: result = {24&apos;b0, result_int4[7:0]};
            2&apos;b01: result = {16&apos;b0, result_int8[15:0]};
            2&apos;b10: result = result_int16;
            default: result = &apos;0;
        endcase
    end
endmodule
</code></pre>
<p><strong>&#x8D44;&#x6E90;&#x6D88;&#x8017;&#x5BF9;&#x6BD4;&#xFF08;Zynq UltraScale+&#xFF09;&#xFF1A;</strong></p>
<ul>
<li>INT4: 1 DSP&#x53EF;&#x8BA1;&#x7B97;4&#x4E2A;MAC</li>
<li>INT8: 1 DSP&#x53EF;&#x8BA1;&#x7B97;2&#x4E2A;MAC  </li>
<li>INT16: 1 DSP&#x8BA1;&#x7B97;1&#x4E2A;MAC</li>
<li>FP16: &#x9700;&#x8981;&#x591A;&#x4E2A;DSP&#x7EA7;&#x8054;</li>
</ul>
<h2 id="113-&#x8109;&#x52A8;&#x9635;&#x5217;vs&#x6570;&#x636E;&#x6D41;&#x67B6;&#x6784;">11.3 &#x8109;&#x52A8;&#x9635;&#x5217;vs&#x6570;&#x636E;&#x6D41;&#x67B6;&#x6784;</h2>
<h3 id="1131-&#x8109;&#x52A8;&#x9635;&#x5217;&#x67B6;&#x6784;">11.3.1 &#x8109;&#x52A8;&#x9635;&#x5217;&#x67B6;&#x6784;</h3>
<pre><code class="lang-systemverilog">// 2D&#x8109;&#x52A8;&#x9635;&#x5217;
module systolic_array_2d #(
    parameter ARRAY_SIZE = 16,
    parameter DATA_WIDTH = 8
) (
    input  logic clk,
    input  logic rst_n,

    // &#x8F93;&#x5165;&#x6570;&#x636E;&#x6D41;
    input  logic [DATA_WIDTH-1:0] a_in[ARRAY_SIZE],  // &#x4ECE;&#x5DE6;&#x4FA7;&#x8F93;&#x5165;
    input  logic [DATA_WIDTH-1:0] b_in[ARRAY_SIZE],  // &#x4ECE;&#x9876;&#x90E8;&#x8F93;&#x5165;

    // &#x8F93;&#x51FA;&#x7ED3;&#x679C;
    output logic [DATA_WIDTH*2-1:0] c_out[ARRAY_SIZE][ARRAY_SIZE]
);
    // PE&#x4E92;&#x8054;&#x4FE1;&#x53F7;
    logic [DATA_WIDTH-1:0] a_wire[ARRAY_SIZE][ARRAY_SIZE+1];
    logic [DATA_WIDTH-1:0] b_wire[ARRAY_SIZE+1][ARRAY_SIZE];

    // &#x8FB9;&#x754C;&#x8FDE;&#x63A5;
    generate
        for (genvar i = 0; i &lt; ARRAY_SIZE; i++) begin
            assign a_wire[i][0] = a_in[i];
            assign b_wire[0][i] = b_in[i];
        end
    endgenerate

    // PE&#x9635;&#x5217;&#x5B9E;&#x4F8B;&#x5316;
    generate
        for (genvar row = 0; row &lt; ARRAY_SIZE; row++) begin : gen_row
            for (genvar col = 0; col &lt; ARRAY_SIZE; col++) begin : gen_col
                systolic_pe #(
                    .DATA_WIDTH(DATA_WIDTH)
                ) pe_inst (
                    .clk(clk),
                    .rst_n(rst_n),
                    .a_in(a_wire[row][col]),
                    .b_in(b_wire[row][col]),
                    .a_out(a_wire[row][col+1]),
                    .b_out(b_wire[row+1][col]),
                    .c_out(c_out[row][col])
                );
            end
        end
    endgenerate
endmodule

// &#x8109;&#x52A8;&#x5904;&#x7406;&#x5355;&#x5143;
module systolic_pe #(
    parameter DATA_WIDTH = 8
) (
    input  logic clk,
    input  logic rst_n,

    input  logic [DATA_WIDTH-1:0] a_in,
    input  logic [DATA_WIDTH-1:0] b_in,
    output logic [DATA_WIDTH-1:0] a_out,
    output logic [DATA_WIDTH-1:0] b_out,
    output logic [DATA_WIDTH*2-1:0] c_out
);
    logic [DATA_WIDTH*2-1:0] acc_reg;

    always_ff @(posedge clk) begin
        if (!rst_n) begin
            acc_reg &lt;= &apos;0;
            a_out &lt;= &apos;0;
            b_out &lt;= &apos;0;
        end else begin
            // &#x6570;&#x636E;&#x4F20;&#x9012;
            a_out &lt;= a_in;
            b_out &lt;= b_in;
            // MAC&#x64CD;&#x4F5C;
            acc_reg &lt;= acc_reg + (a_in * b_in);
        end
    end

    assign c_out = acc_reg;
endmodule
</code></pre>
<p><strong>&#x8109;&#x52A8;&#x9635;&#x5217;&#x7279;&#x70B9;&#xFF1A;</strong></p>
<ul>
<li>&#x89C4;&#x5219;&#x7684;&#x6570;&#x636E;&#x6D41;&#x52A8;</li>
<li>&#x9AD8;&#x5E26;&#x5BBD;&#x5229;&#x7528;&#x7387;</li>
<li>&#x56FA;&#x5B9A;&#x7684;&#x8BA1;&#x7B97;&#x6A21;&#x5F0F;</li>
<li>&#x9002;&#x5408;&#x77E9;&#x9635;&#x4E58;&#x6CD5;</li>
</ul>
<h3 id="1132-&#x6570;&#x636E;&#x6D41;&#x67B6;&#x6784;">11.3.2 &#x6570;&#x636E;&#x6D41;&#x67B6;&#x6784;</h3>
<pre><code class="lang-systemverilog">// &#x6570;&#x636E;&#x6D41;&#x5904;&#x7406;&#x5F15;&#x64CE;
module dataflow_engine #(
    parameter NUM_PES = 64,
    parameter FIFO_DEPTH = 32
) (
    input  logic clk,
    input  logic rst_n,

    // &#x914D;&#x7F6E;&#x63A5;&#x53E3;
    input  logic [31:0] config_data,
    input  logic        config_valid,

    // &#x6570;&#x636E;&#x8F93;&#x5165;&#x8F93;&#x51FA;
    input  logic [15:0] data_in,
    input  logic        data_in_valid,
    output logic        data_in_ready,

    output logic [15:0] data_out,
    output logic        data_out_valid,
    input  logic        data_out_ready
);
    // PE&#x95F4;FIFO&#x8FDE;&#x63A5;
    logic [15:0] fifo_data[NUM_PES];
    logic        fifo_valid[NUM_PES];
    logic        fifo_ready[NUM_PES];

    // &#x53EF;&#x914D;&#x7F6E;PE&#x9635;&#x5217;
    generate
        for (genvar i = 0; i &lt; NUM_PES; i++) begin : gen_pe
            configurable_pe pe_inst (
                .clk(clk),
                .rst_n(rst_n),

                // &#x914D;&#x7F6E;
                .config_data(config_data),
                .config_valid(config_valid &amp; (config_data[7:0] == i)),

                // &#x6570;&#x636E;&#x8DEF;&#x5F84;
                .data_in(i == 0 ? data_in : fifo_data[i-1]),
                .data_in_valid(i == 0 ? data_in_valid : fifo_valid[i-1]),
                .data_in_ready(i == 0 ? data_in_ready : fifo_ready[i-1]),

                .data_out(fifo_data[i]),
                .data_out_valid(fifo_valid[i]),
                .data_out_ready(i == NUM_PES-1 ? data_out_ready : fifo_ready[i])
            );
        end
    endgenerate

    // &#x8F93;&#x51FA;&#x8FDE;&#x63A5;
    assign data_out = fifo_data[NUM_PES-1];
    assign data_out_valid = fifo_valid[NUM_PES-1];
endmodule
</code></pre>
<h3 id="1133-&#x67B6;&#x6784;&#x5BF9;&#x6BD4;&#x4E0E;&#x9009;&#x62E9;">11.3.3 &#x67B6;&#x6784;&#x5BF9;&#x6BD4;&#x4E0E;&#x9009;&#x62E9;</h3>
<pre><code class="lang-systemverilog">// &#x6DF7;&#x5408;&#x67B6;&#x6784;&#x793A;&#x4F8B;
module hybrid_accelerator (
    input  logic clk,
    input  logic rst_n,

    // &#x63A7;&#x5236;
    input  logic mode_select, // 0: systolic, 1: dataflow

    // &#x7EDF;&#x4E00;&#x63A5;&#x53E3;
    axi_stream_if.slave  s_axis,
    axi_stream_if.master m_axis
);
    // &#x8109;&#x52A8;&#x9635;&#x5217;&#x8DEF;&#x5F84;
    systolic_array_2d #(
        .ARRAY_SIZE(16)
    ) systolic_inst (
        .clk(clk),
        .rst_n(rst_n),
        .a_in(/* &#x8FDE;&#x63A5; */),
        .b_in(/* &#x8FDE;&#x63A5; */),
        .c_out(/* &#x8FDE;&#x63A5; */)
    );

    // &#x6570;&#x636E;&#x6D41;&#x8DEF;&#x5F84;
    dataflow_engine #(
        .NUM_PES(64)
    ) dataflow_inst (
        .clk(clk),
        .rst_n(rst_n),
        .data_in(/* &#x8FDE;&#x63A5; */),
        .data_out(/* &#x8FDE;&#x63A5; */)
    );

    // &#x8DEF;&#x5F84;&#x9009;&#x62E9;&#x903B;&#x8F91;
    always_comb begin
        if (mode_select == 1&apos;b0) begin
            // &#x8DEF;&#x7531;&#x5230;&#x8109;&#x52A8;&#x9635;&#x5217;
        end else begin
            // &#x8DEF;&#x7531;&#x5230;&#x6570;&#x636E;&#x6D41;&#x5F15;&#x64CE;
        end
    end
endmodule
</code></pre>
<p><strong>&#x67B6;&#x6784;&#x9009;&#x62E9;&#x6307;&#x5357;&#xFF1A;</strong></p>
<table>
<thead>
<tr>
<th>&#x7279;&#x6027;</th>
<th>&#x8109;&#x52A8;&#x9635;&#x5217;</th>
<th>&#x6570;&#x636E;&#x6D41;</th>
<th>&#x6DF7;&#x5408;&#x67B6;&#x6784;</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#x9002;&#x7528;&#x573A;&#x666F;</td>
<td>GEMM&#x3001;&#x5377;&#x79EF;</td>
<td>&#x4E0D;&#x89C4;&#x5219;&#x8BA1;&#x7B97;</td>
<td>&#x591A;&#x6837;&#x5316;&#x8D1F;&#x8F7D;</td>
</tr>
<tr>
<td>&#x6570;&#x636E;&#x91CD;&#x7528;</td>
<td>&#x9AD8;</td>
<td>&#x4E2D;</td>
<td>&#x53EF;&#x914D;&#x7F6E;</td>
</tr>
<tr>
<td>&#x7075;&#x6D3B;&#x6027;</td>
<td>&#x4F4E;</td>
<td>&#x9AD8;</td>
<td>&#x9AD8;</td>
</tr>
<tr>
<td>&#x9762;&#x79EF;&#x6548;&#x7387;</td>
<td>&#x9AD8;</td>
<td>&#x4E2D;</td>
<td>&#x4E2D;</td>
</tr>
<tr>
<td>&#x7F16;&#x7A0B;&#x590D;&#x6742;&#x5EA6;</td>
<td>&#x4F4E;</td>
<td>&#x9AD8;</td>
<td>&#x9AD8;</td>
</tr>
<tr>
<td>&#x529F;&#x8017;&#x6548;&#x7387;</td>
<td>&#x4F18;&#x79C0;</td>
<td>&#x826F;&#x597D;</td>
<td>&#x826F;&#x597D;</td>
</tr>
<tr>
<td>&#x5185;&#x5B58;&#x5E26;&#x5BBD;&#x9700;&#x6C42;</td>
<td>&#x4F4E;</td>
<td>&#x9AD8;</td>
<td>&#x4E2D;</td>
</tr>
</tbody>
</table>
<p><strong>&#x5B9E;&#x9645;&#x5E94;&#x7528;&#x6848;&#x4F8B;&#x5206;&#x6790;&#xFF1A;</strong></p>
<ol>
<li><p><strong>CNN&#x63A8;&#x7406;&#x52A0;&#x901F;&#x5668;&#xFF08;&#x8109;&#x52A8;&#x9635;&#x5217;&#xFF09;</strong></p>
<ul>
<li>ResNet-50: 16&#xD7;16&#x8109;&#x52A8;&#x9635;&#x5217;</li>
<li>&#x6570;&#x636E;&#x91CD;&#x7528;&#x7387;: 93%</li>
<li>DSP&#x5229;&#x7528;&#x7387;: 95%</li>
<li>&#x529F;&#x8017;: 15W @200MHz</li>
</ul>
</li>
<li><p><strong>Transformer&#x52A0;&#x901F;&#x5668;&#xFF08;&#x6570;&#x636E;&#x6D41;&#xFF09;</strong></p>
<ul>
<li>BERT-Base: &#x53EF;&#x91CD;&#x6784;&#x6570;&#x636E;&#x6D41;</li>
<li>&#x652F;&#x6301;&#x52A8;&#x6001;&#x5E8F;&#x5217;&#x957F;&#x5EA6;</li>
<li>&#x5185;&#x5B58;&#x5E26;&#x5BBD;: 25.6GB/s</li>
<li>&#x5EF6;&#x8FDF;&#x53D8;&#x5316;: &#xB1;15%</li>
</ul>
</li>
<li><p><strong>&#x901A;&#x7528;AI&#x52A0;&#x901F;&#x5668;&#xFF08;&#x6DF7;&#x5408;&#x67B6;&#x6784;&#xFF09;</strong></p>
<ul>
<li>&#x652F;&#x6301;CNN/RNN/Transformer</li>
<li>&#x6A21;&#x5F0F;&#x5207;&#x6362;&#x5F00;&#x9500;: &lt;1&#x3BC;s</li>
<li>&#x8D44;&#x6E90;&#x5171;&#x4EAB;&#x7387;: 80%</li>
<li>&#x9762;&#x79EF;&#x5F00;&#x9500;: +20%</li>
</ul>
</li>
</ol>
<p><strong>&#x6027;&#x80FD;&#x5EFA;&#x6A21;&#x4E0E;&#x8BC4;&#x4F30;&#xFF1A;</strong></p>
<pre><code class="lang-systemverilog">// &#x6027;&#x80FD;&#x8BA1;&#x6570;&#x5668;&#x6A21;&#x5757;
module performance_monitor (
    input  logic        clk,
    input  logic        rst_n,

    // &#x76D1;&#x63A7;&#x4FE1;&#x53F7;
    input  logic        compute_active,
    input  logic        memory_stall,
    input  logic        pipeline_flush,

    // &#x6027;&#x80FD;&#x6307;&#x6807;&#x8F93;&#x51FA;
    output logic [31:0] cycle_count,
    output logic [31:0] active_cycles,
    output logic [31:0] stall_cycles,
    output logic [31:0] mac_operations
);
    // &#x8BA1;&#x6570;&#x5668;&#x903B;&#x8F91;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            cycle_count &lt;= &apos;0;
            active_cycles &lt;= &apos;0;
            stall_cycles &lt;= &apos;0;
        end else begin
            cycle_count &lt;= cycle_count + 1;
            if (compute_active) active_cycles &lt;= active_cycles + 1;
            if (memory_stall) stall_cycles &lt;= stall_cycles + 1;
        end
    end

    // &#x8BA1;&#x7B97;&#x5229;&#x7528;&#x7387;
    logic [7:0] utilization;
    assign utilization = (active_cycles * 100) / cycle_count;
endmodule
</code></pre>
<p><strong>&#x8D44;&#x6E90;&#x9884;&#x7B97;&#x5206;&#x6790;&#xFF08;Zynq UltraScale+ ZU9EG&#xFF09;&#xFF1A;</strong></p>
<pre><code>&#x8109;&#x52A8;&#x9635;&#x5217; (16&#xD7;16):
- LUT: 45K (8%)
- DSP: 256 (10%)
- BRAM: 128 (14%)
- &#x5CF0;&#x503C;&#x6027;&#x80FD;: 51.2 GOPS @200MHz

&#x6570;&#x636E;&#x6D41;&#x67B6;&#x6784; (64 PE):
- LUT: 85K (15%)
- DSP: 192 (7.5%)
- BRAM: 256 (28%)
- &#x5CF0;&#x503C;&#x6027;&#x80FD;: 38.4 GOPS @200MHz

&#x6DF7;&#x5408;&#x67B6;&#x6784;:
- LUT: 110K (19%)
- DSP: 384 (15%)
- BRAM: 320 (35%)
- &#x5CF0;&#x503C;&#x6027;&#x80FD;: 76.8 GOPS @200MHz
</code></pre><p><strong>&#x51B3;&#x7B56;&#x6811;&#xFF1A;</strong></p>
<pre><code>1. &#x5DE5;&#x4F5C;&#x8D1F;&#x8F7D;&#x5206;&#x6790;
   &#x251C;&#x2500; &#x89C4;&#x5219;&#x8BA1;&#x7B97;&#x4E3A;&#x4E3B;&#xFF08;&gt;80%&#xFF09;
   &#x2502;  &#x2514;&#x2500; &#x8109;&#x52A8;&#x9635;&#x5217;
   &#x251C;&#x2500; &#x4E0D;&#x89C4;&#x5219;&#x8BA1;&#x7B97;&#x4E3A;&#x4E3B;
   &#x2502;  &#x2514;&#x2500; &#x6570;&#x636E;&#x6D41;
   &#x2514;&#x2500; &#x6DF7;&#x5408;&#x8D1F;&#x8F7D;
      &#x2514;&#x2500; &#x6DF7;&#x5408;&#x67B6;&#x6784;

2. &#x7EA6;&#x675F;&#x6761;&#x4EF6;&#x8BC4;&#x4F30;
   &#x251C;&#x2500; &#x529F;&#x8017;&#x53D7;&#x9650; (&lt;10W)
   &#x2502;  &#x2514;&#x2500; &#x4F18;&#x5316;&#x8109;&#x52A8;&#x9635;&#x5217;
   &#x251C;&#x2500; &#x5EF6;&#x8FDF;&#x654F;&#x611F; (&lt;1ms)
   &#x2502;  &#x2514;&#x2500; &#x5E76;&#x884C;&#x6570;&#x636E;&#x6D41;
   &#x2514;&#x2500; &#x541E;&#x5410;&#x91CF;&#x4F18;&#x5148;
      &#x2514;&#x2500; &#x6DF1;&#x5EA6;&#x6D41;&#x6C34;&#x7EBF;
</code></pre><h2 id="114-fpga-vs-gpu-vs-tpu">11.4 FPGA vs GPU vs TPU</h2>
<h3 id="1141-&#x67B6;&#x6784;&#x7279;&#x5F81;&#x5BF9;&#x6BD4;">11.4.1 &#x67B6;&#x6784;&#x7279;&#x5F81;&#x5BF9;&#x6BD4;</h3>
<p><strong>&#x8BA1;&#x7B97;&#x67B6;&#x6784;&#x5DEE;&#x5F02;&#xFF1A;</strong></p>
<pre><code class="lang-systemverilog">// FPGA&#x7279;&#x5F81;&#xFF1A;&#x7EC6;&#x7C92;&#x5EA6;&#x5E76;&#x884C;
module fpga_compute_unit (
    input  logic        clk,
    input  logic [7:0]  precision_config, // &#x53EF;&#x53D8;&#x7CBE;&#x5EA6;

    // &#x81EA;&#x5B9A;&#x4E49;&#x6570;&#x636E;&#x8DEF;&#x5F84;
    input  logic [127:0] custom_data_in,
    output logic [127:0] custom_data_out
);
    // &#x5B8C;&#x5168;&#x53EF;&#x5B9A;&#x5236;&#x7684;&#x8BA1;&#x7B97;&#x7BA1;&#x7EBF;
    // &#x53EF;&#x4EE5;&#x5B9E;&#x73B0;&#x4EFB;&#x610F;&#x7CBE;&#x5EA6;&#x3001;&#x4EFB;&#x610F;&#x8FD0;&#x7B97;
endmodule
</code></pre>
<p><strong>&#x67B6;&#x6784;&#x5BF9;&#x6BD4;&#x8868;&#xFF1A;</strong></p>
<table>
<thead>
<tr>
<th>&#x7279;&#x6027;</th>
<th>FPGA</th>
<th>GPU</th>
<th>TPU</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#x5E76;&#x884C;&#x7C92;&#x5EA6;</td>
<td>&#x4F4D;&#x7EA7;</td>
<td>&#x7EBF;&#x7A0B;&#x7EA7;</td>
<td>&#x77E9;&#x9635;&#x7EA7;</td>
</tr>
<tr>
<td>&#x5185;&#x5B58;&#x5C42;&#x6B21;</td>
<td>&#x53EF;&#x5B9A;&#x5236;</td>
<td>&#x56FA;&#x5B9A;&#x5C42;&#x6B21;</td>
<td>&#x4E13;&#x7528;&#x7F13;&#x5B58;</td>
</tr>
<tr>
<td>&#x6570;&#x636E;&#x7CBE;&#x5EA6;</td>
<td>&#x4EFB;&#x610F;</td>
<td>FP32/16/INT8</td>
<td>INT8/BF16</td>
</tr>
<tr>
<td>&#x529F;&#x8017;&#x6548;&#x7387;</td>
<td>&#x6700;&#x9AD8;</td>
<td>&#x4E2D;&#x7B49;</td>
<td>&#x9AD8;</td>
</tr>
<tr>
<td>&#x7F16;&#x7A0B;&#x6A21;&#x578B;</td>
<td>HDL</td>
<td>CUDA/OpenCL</td>
<td>XLA</td>
</tr>
<tr>
<td>&#x90E8;&#x7F72;&#x7075;&#x6D3B;&#x6027;</td>
<td>&#x9AD8;</td>
<td>&#x4E2D;</td>
<td>&#x4F4E;</td>
</tr>
</tbody>
</table>
<h3 id="1142-&#x6027;&#x80FD;&#x4E0E;&#x529F;&#x8017;&#x5206;&#x6790;">11.4.2 &#x6027;&#x80FD;&#x4E0E;&#x529F;&#x8017;&#x5206;&#x6790;</h3>
<p><strong>&#x63A8;&#x7406;&#x6027;&#x80FD;&#x5BF9;&#x6BD4;&#xFF08;ResNet-50&#xFF09;&#xFF1A;</strong></p>
<pre><code>FPGA (Xilinx VU9P):
- &#x541E;&#x5410;&#x91CF;: 3,200 images/s
- &#x5EF6;&#x8FDF;: 0.31ms
- &#x529F;&#x8017;: 75W
- &#x6027;&#x80FD;/&#x74E6;&#x7279;: 42.7 img/s/W

GPU (NVIDIA V100):
- &#x541E;&#x5410;&#x91CF;: 7,800 images/s  
- &#x5EF6;&#x8FDF;: 0.13ms
- &#x529F;&#x8017;: 300W
- &#x6027;&#x80FD;/&#x74E6;&#x7279;: 26 img/s/W

TPU v3:
- &#x541E;&#x5410;&#x91CF;: 12,000 images/s
- &#x5EF6;&#x8FDF;: 0.08ms
- &#x529F;&#x8017;: 200W
- &#x6027;&#x80FD;/&#x74E6;&#x7279;: 60 img/s/W
</code></pre><p><strong>&#x5EF6;&#x8FDF;&#x654F;&#x611F;&#x573A;&#x666F;&#x5206;&#x6790;&#xFF1A;</strong></p>
<pre><code class="lang-systemverilog">// FPGA&#x4F4E;&#x5EF6;&#x8FDF;&#x63A8;&#x7406;&#x7BA1;&#x7EBF;
module low_latency_inference (
    input  logic        clk,
    input  logic [15:0] sensor_data,
    output logic [7:0]  inference_result,
    output logic        result_valid
);
    // &#x6D41;&#x6C34;&#x7EBF;&#x6DF1;&#x5EA6;&#xFF1A;8&#x7EA7;
    // &#x56FA;&#x5B9A;&#x5EF6;&#x8FDF;&#xFF1A;40ns (8 cycles @ 200MHz)

    // &#x7B2C;1&#x7EA7;&#xFF1A;&#x6570;&#x636E;&#x9884;&#x5904;&#x7406;
    logic [15:0] stage1_data;
    always_ff @(posedge clk) begin
        stage1_data &lt;= sensor_data &gt;&gt; 2; // &#x5F52;&#x4E00;&#x5316;
    end

    // &#x7B2C;2-7&#x7EA7;&#xFF1A;&#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x5C42;
    // ...&#x7701;&#x7565;&#x4E2D;&#x95F4;&#x7EA7;...

    // &#x7B2C;8&#x7EA7;&#xFF1A;&#x8F93;&#x51FA;
    always_ff @(posedge clk) begin
        inference_result &lt;= final_activation;
        result_valid &lt;= 1&apos;b1;
    end
endmodule
</code></pre>
<h3 id="1143-&#x5E94;&#x7528;&#x573A;&#x666F;&#x9009;&#x62E9;">11.4.3 &#x5E94;&#x7528;&#x573A;&#x666F;&#x9009;&#x62E9;</h3>
<p><strong>&#x51B3;&#x7B56;&#x77E9;&#x9635;&#xFF1A;</strong></p>
<pre><code>&#x573A;&#x666F;&#x5206;&#x6790;&#xFF1A;
1. &#x8FB9;&#x7F18;AI&#x63A8;&#x7406;
   - &#x529F;&#x8017;&#x53D7;&#x9650; (&lt;10W) &#x2192; FPGA
   - &#x6210;&#x672C;&#x654F;&#x611F; &#x2192; &#x4E13;&#x7528;ASIC
   - &#x901A;&#x7528;&#x6027;&#x8981;&#x6C42; &#x2192; &#x5D4C;&#x5165;&#x5F0F;GPU

2. &#x6570;&#x636E;&#x4E2D;&#x5FC3;&#x63A8;&#x7406;
   - &#x5927;&#x6279;&#x91CF;&#x5904;&#x7406; &#x2192; TPU
   - &#x6DF7;&#x5408;&#x8D1F;&#x8F7D; &#x2192; GPU
   - &#x5B9A;&#x5236;&#x7B97;&#x6CD5; &#x2192; FPGA

3. &#x5B9E;&#x65F6;&#x5904;&#x7406;
   - &#x786E;&#x5B9A;&#x6027;&#x5EF6;&#x8FDF; &#x2192; FPGA
   - &#x9AD8;&#x541E;&#x5410;&#x91CF; &#x2192; TPU
   - &#x7075;&#x6D3B;&#x90E8;&#x7F72; &#x2192; GPU
</code></pre><p><strong>&#x6210;&#x672C;&#x6548;&#x76CA;&#x5206;&#x6790;&#xFF1A;</strong></p>
<table>
<thead>
<tr>
<th>&#x6307;&#x6807;</th>
<th>FPGA</th>
<th>GPU</th>
<th>TPU</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#x786C;&#x4EF6;&#x6210;&#x672C;</td>
<td>$5,000-20,000</td>
<td>$10,000-15,000</td>
<td>$30,000+</td>
</tr>
<tr>
<td>&#x5F00;&#x53D1;&#x6210;&#x672C;</td>
<td>&#x9AD8;</td>
<td>&#x4E2D;</td>
<td>&#x4F4E;</td>
</tr>
<tr>
<td>&#x90E8;&#x7F72;&#x65F6;&#x95F4;</td>
<td>6-12&#x6708;</td>
<td>1-3&#x6708;</td>
<td>1&#x6708;</td>
</tr>
<tr>
<td>TCO (3&#x5E74;)</td>
<td>&#x4E2D;</td>
<td>&#x9AD8;</td>
<td>&#x4F4E;*</td>
</tr>
</tbody>
</table>
<p>*&#x6CE8;&#xFF1A;TPU&#x4EC5;&#x5728;Google Cloud&#x53EF;&#x7528;</p>
<h3 id="1144-&#x6DF7;&#x5408;&#x8BA1;&#x7B97;&#x67B6;&#x6784;">11.4.4 &#x6DF7;&#x5408;&#x8BA1;&#x7B97;&#x67B6;&#x6784;</h3>
<pre><code class="lang-systemverilog">// CPU+FPGA&#x534F;&#x540C;&#x8BA1;&#x7B97;
module heterogeneous_compute (
    // PCIe&#x63A5;&#x53E3;&#x5230;CPU
    pcie_if.slave cpu_if,

    // &#x9AD8;&#x5E26;&#x5BBD;&#x5185;&#x5B58;&#x63A5;&#x53E3;
    hbm_if.master hbm_if,

    // &#x52A0;&#x901F;&#x5668;&#x63A7;&#x5236;
    input logic [31:0] accel_config
);
    // &#x4EFB;&#x52A1;&#x8C03;&#x5EA6;&#x5668;
    task_scheduler scheduler_inst (
        .cpu_tasks(cpu_queue),
        .fpga_tasks(fpga_queue),
        .load_balance_enable(1&apos;b1)
    );

    // FPGA&#x52A0;&#x901F;&#x5F15;&#x64CE;
    ai_accelerator accel_inst (
        .task_in(fpga_queue),
        .result_out(result_queue)
    );
endmodule
</code></pre>
<p><strong>&#x4F18;&#x5316;&#x7B56;&#x7565;&#x5BF9;&#x6BD4;&#xFF1A;</strong></p>
<ol>
<li><p><strong>FPGA&#x4F18;&#x5316;</strong></p>
<ul>
<li>&#x7B97;&#x6CD5;-&#x786C;&#x4EF6;&#x534F;&#x540C;&#x8BBE;&#x8BA1;</li>
<li>&#x5B9A;&#x5236;&#x6570;&#x636E;&#x901A;&#x8DEF;</li>
<li>&#x8FD1;&#x6570;&#x636E;&#x8BA1;&#x7B97;</li>
</ul>
</li>
<li><p><strong>GPU&#x4F18;&#x5316;</strong></p>
<ul>
<li>&#x6838;&#x51FD;&#x6570;&#x878D;&#x5408;</li>
<li>&#x5F20;&#x91CF;&#x6838;&#x5FC3;&#x5229;&#x7528;</li>
<li>&#x591A;&#x6D41;&#x5E76;&#x53D1;</li>
</ul>
</li>
<li><p><strong>TPU&#x4F18;&#x5316;</strong></p>
<ul>
<li>&#x6279;&#x91CF;&#x5927;&#x5C0F;&#x8C03;&#x4F18;</li>
<li>XLA&#x7F16;&#x8BD1;&#x4F18;&#x5316;</li>
<li>&#x6A21;&#x578B;&#x91CF;&#x5316;</li>
</ul>
</li>
</ol>
<hr>
<div style="text-align: center; margin: 20px 0;">
  <a href="chapter10.html" style="margin-right: 20px;">&#x2190; &#x4E0A;&#x4E00;&#x7AE0;&#xFF1A;&#x672A;&#x6765;&#x8D8B;&#x52BF;&#x4E0E;&#x65B0;&#x5174;&#x6280;&#x672F;</a>
  <a href="chapter12.html" style="margin-left: 20px;">&#x4E0B;&#x4E00;&#x7AE0;&#xFF1A;LLM&#x63A8;&#x7406;&#x52A0;&#x901F; &#x2192;</a>
</div>



<script type="text/javascript">var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}</script>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter10.html" class="navigation navigation-prev " aria-label="Previous page: 第10章：零知识证明加速器">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter12.html" class="navigation navigation-next " aria-label="Next page: 第12章：LLM推理加速">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第11章：AI加速器基础","level":"4.1","depth":1,"next":{"title":"第12章：LLM推理加速","level":"4.2","depth":1,"path":"chapters/chapter12.md","ref":"chapters/chapter12.md","articles":[]},"previous":{"title":"第10章：零知识证明加速器","level":"3.6","depth":1,"path":"chapters/chapter10.md","ref":"chapters/chapter10.md","articles":[]},"dir":"ltr"},"config":{"plugins":["expandable-chapters","search","copy-code-button","theme-default","back-to-top-button","github","splitter","toc"],"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"},"pluginsConfig":{"github":{"url":"https://github.com/Xde1997/Tutorial_FPGA"},"splitter":{},"toc":{"addClass":true,"className":"toc"},"search":{"maxIndexSize":100000,"ignoreCase":true},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"back-to-top-button":{},"copy-code-button":{"copyText":"复制","format":"html"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"showLevel":true,"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"styles/website.css"}},"expandable-chapters":{}},"theme":"default","author":"FPGA教程团队","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"themeColor":"#3f51b5","themeColorSecondary":"#ff4081"},"title":"FPGA原理与AI加速应用教程","language":"zh-hans","gitbook":"*","description":"面向软件工程师的FPGA实战指南"},"file":{"path":"chapters/chapter11.md","mtime":"2025-08-03T12:35:55.486Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2025-08-03T12:37:10.363Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

