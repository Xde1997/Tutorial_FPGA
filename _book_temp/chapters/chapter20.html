
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>第20章：多FPGA系统与扩展 · FPGA原理与AI加速应用教程</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="FPGA教程团队">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
        <link rel="stylesheet" href="../assets/css/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter21.html" />
    
    
    <link rel="prev" href="chapter19.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                        <b>1.1.</b>
                    
                    介绍
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第一部分：FPGA基础架构</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="chapter1.html">
            
                <a href="chapter1.html">
            
                    
                        <b>2.1.</b>
                    
                    第1章：FPGA基础架构与工作原理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="chapter2.html">
            
                <a href="chapter2.html">
            
                    
                        <b>2.2.</b>
                    
                    第2章：HDL设计基础与方法学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="chapter3.html">
            
                <a href="chapter3.html">
            
                    
                        <b>2.3.</b>
                    
                    第3章：时序、时钟与同步
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="chapter4.html">
            
                <a href="chapter4.html">
            
                    
                        <b>2.4.</b>
                    
                    第4章：存储器系统与接口设计
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第二部分：高级设计技术</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="chapter5.html">
            
                <a href="chapter5.html">
            
                    
                        <b>3.1.</b>
                    
                    第5章：高速I/O与通信
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="chapter6.html">
            
                <a href="chapter6.html">
            
                    
                        <b>3.2.</b>
                    
                    第6章：DSP与算术优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="chapter7.html">
            
                <a href="chapter7.html">
            
                    
                        <b>3.3.</b>
                    
                    第7章：HLS与C到硬件综合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" data-path="chapter8.html">
            
                <a href="chapter8.html">
            
                    
                        <b>3.4.</b>
                    
                    第8章：函数式HDL之Haskell/Clash
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" data-path="chapter9.html">
            
                <a href="chapter9.html">
            
                    
                        <b>3.5.</b>
                    
                    第9章：OCaml/Hardcaml硬件设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.6" data-path="chapter10.html">
            
                <a href="chapter10.html">
            
                    
                        <b>3.6.</b>
                    
                    第10章：零知识证明加速器
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第三部分：AI加速实战</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="chapter11.html">
            
                <a href="chapter11.html">
            
                    
                        <b>4.1.</b>
                    
                    第11章：AI加速器基础
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="chapter12.html">
            
                <a href="chapter12.html">
            
                    
                        <b>4.2.</b>
                    
                    第12章：LLM推理加速
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="chapter13.html">
            
                <a href="chapter13.html">
            
                    
                        <b>4.3.</b>
                    
                    第13章：视觉与多模态处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="chapter14.html">
            
                <a href="chapter14.html">
            
                    
                        <b>4.4.</b>
                    
                    第14章：LLM服务基础设施
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="chapter15.html">
            
                <a href="chapter15.html">
            
                    
                        <b>4.5.</b>
                    
                    第15章：机器人运动控制与FPGA
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.6" data-path="chapter16.html">
            
                <a href="chapter16.html">
            
                    
                        <b>4.6.</b>
                    
                    第16章：激光雷达信号处理与FPGA
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.7" data-path="chapter17.html">
            
                <a href="chapter17.html">
            
                    
                        <b>4.7.</b>
                    
                    第17章：毫米波雷达与FPGA
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">第四部分：高级优化与扩展</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="chapter18.html">
            
                <a href="chapter18.html">
            
                    
                        <b>5.1.</b>
                    
                    第18章：性能分析与优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="chapter19.html">
            
                <a href="chapter19.html">
            
                    
                        <b>5.2.</b>
                    
                    第19章：功耗优化技术
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="5.3" data-path="chapter20.html">
            
                <a href="chapter20.html">
            
                    
                        <b>5.3.</b>
                    
                    第20章：多FPGA系统与扩展
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.4" data-path="chapter21.html">
            
                <a href="chapter21.html">
            
                    
                        <b>5.4.</b>
                    
                    第21章：可靠性与容错设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.5" data-path="chapter22.html">
            
                <a href="chapter22.html">
            
                    
                        <b>5.5.</b>
                    
                    第22章：未来趋势与新兴技术
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../docs/DEPLOY_README.md">
            
                <span>
            
                    
                        <b>6.1.</b>
                    
                    部署指南
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2" data-path="../docs/GITBOOK_SETUP.md">
            
                <span>
            
                    
                        <b>6.2.</b>
                    
                    安装说明
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3" data-path="../docs/CONVERSION_SUMMARY.md">
            
                <span>
            
                    
                        <b>6.3.</b>
                    
                    转换总结
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >第20章：多FPGA系统与扩展</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="&#x7B2C;17&#x7AE0;&#xFF1A;&#x591A;fpga&#x7CFB;&#x7EDF;&#x4E0E;&#x6269;&#x5C55;">&#x7B2C;17&#x7AE0;&#xFF1A;&#x591A;FPGA&#x7CFB;&#x7EDF;&#x4E0E;&#x6269;&#x5C55;</h1>
<p>&#x968F;&#x7740;AI&#x6A21;&#x578B;&#x89C4;&#x6A21;&#x7684;&#x7206;&#x70B8;&#x6027;&#x589E;&#x957F;&#x548C;&#x8BA1;&#x7B97;&#x9700;&#x6C42;&#x7684;&#x4E0D;&#x65AD;&#x63D0;&#x5347;&#xFF0C;&#x5355;&#x7247;FPGA&#x7684;&#x8D44;&#x6E90;&#x5DF2;&#x96BE;&#x4EE5;&#x6EE1;&#x8DB3;&#x5927;&#x89C4;&#x6A21;&#x5E94;&#x7528;&#x7684;&#x9700;&#x6C42;&#x3002;&#x672C;&#x7AE0;&#x6DF1;&#x5165;&#x63A2;&#x8BA8;&#x591A;FPGA&#x7CFB;&#x7EDF;&#x7684;&#x8BBE;&#x8BA1;&#x539F;&#x7406;&#x3001;&#x4E92;&#x8054;&#x67B6;&#x6784;&#x3001;&#x5206;&#x5E03;&#x5F0F;&#x8BA1;&#x7B97;&#x6A21;&#x578B;&#x4EE5;&#x53CA;&#x6700;&#x65B0;&#x7684;Chiplet&#x6280;&#x672F;&#xFF0C;&#x5E2E;&#x52A9;&#x8BFB;&#x8005;&#x638C;&#x63E1;&#x6784;&#x5EFA;&#x53EF;&#x6269;&#x5C55;FPGA&#x96C6;&#x7FA4;&#x7684;&#x5173;&#x952E;&#x6280;&#x672F;&#x3002;&#x6211;&#x4EEC;&#x5C06;&#x91CD;&#x70B9;&#x5206;&#x6790;&#x5982;&#x4F55;&#x7A81;&#x7834;&#x5355;&#x82AF;&#x7247;&#x9650;&#x5236;&#xFF0C;&#x5B9E;&#x73B0;&#x8FD1;&#x7EBF;&#x6027;&#x7684;&#x6027;&#x80FD;&#x6269;&#x5C55;&#xFF0C;&#x5E76;&#x63A2;&#x8BA8;&#x5728;AI&#x63A8;&#x7406;&#x3001;&#x79D1;&#x5B66;&#x8BA1;&#x7B97;&#x7B49;&#x9886;&#x57DF;&#x7684;&#x5B9E;&#x9645;&#x5E94;&#x7528;&#x3002;</p>
<h2 id="171-fpga&#x95F4;&#x9AD8;&#x901F;&#x4E92;&#x8054;&#x67B6;&#x6784;">17.1 FPGA&#x95F4;&#x9AD8;&#x901F;&#x4E92;&#x8054;&#x67B6;&#x6784;</h2>
<h3 id="1711-&#x4E92;&#x8054;&#x62D3;&#x6251;&#x8BBE;&#x8BA1;">17.1.1 &#x4E92;&#x8054;&#x62D3;&#x6251;&#x8BBE;&#x8BA1;</h3>
<p>&#x591A;FPGA&#x7CFB;&#x7EDF;&#x7684;&#x6027;&#x80FD;&#x5F88;&#x5927;&#x7A0B;&#x5EA6;&#x4E0A;&#x53D6;&#x51B3;&#x4E8E;&#x4E92;&#x8054;&#x67B6;&#x6784;&#x7684;&#x8BBE;&#x8BA1;&#x3002;&#x5E38;&#x89C1;&#x7684;&#x62D3;&#x6251;&#x7ED3;&#x6784;&#x5305;&#x62EC;&#xFF1A;</p>
<p><strong>1. &#x5168;&#x8FDE;&#x63A5;&#x7F51;&#x683C;&#xFF08;Full Mesh&#xFF09;</strong></p>
<ul>
<li>&#x6BCF;&#x4E2A;FPGA&#x4E0E;&#x5176;&#x4ED6;&#x6240;&#x6709;FPGA&#x76F4;&#x63A5;&#x76F8;&#x8FDE;</li>
<li>&#x4F18;&#x70B9;&#xFF1A;&#x6700;&#x4F4E;&#x5EF6;&#x8FDF;&#xFF0C;&#x65E0;&#x8DEF;&#x7531;&#x51B2;&#x7A81;</li>
<li>&#x7F3A;&#x70B9;&#xFF1A;&#x8FDE;&#x63A5;&#x6570;&#x4E3A;O(N&#xB2;)&#xFF0C;&#x6269;&#x5C55;&#x6027;&#x5DEE;</li>
<li>&#x9002;&#x7528;&#x573A;&#x666F;&#xFF1A;4-8&#x7247;FPGA&#x7684;&#x5C0F;&#x89C4;&#x6A21;&#x7CFB;&#x7EDF;</li>
</ul>
<p><strong>2. &#x73AF;&#x5F62;&#x62D3;&#x6251;&#xFF08;Ring&#xFF09;</strong></p>
<ul>
<li>FPGA&#x6309;&#x73AF;&#x5F62;&#x8FDE;&#x63A5;&#xFF0C;&#x652F;&#x6301;&#x53CC;&#x5411;&#x901A;&#x4FE1;</li>
<li>&#x4F18;&#x70B9;&#xFF1A;&#x8FDE;&#x63A5;&#x7B80;&#x5355;&#xFF0C;&#x6613;&#x4E8E;&#x6269;&#x5C55;</li>
<li>&#x7F3A;&#x70B9;&#xFF1A;&#x5E73;&#x5747;&#x8DF3;&#x6570;&#x8F83;&#x9AD8;&#xFF0C;&#x5E26;&#x5BBD;&#x53D7;&#x9650;</li>
<li>&#x9002;&#x7528;&#x573A;&#x666F;&#xFF1A;&#x6D41;&#x5F0F;&#x5904;&#x7406;&#xFF0C;&#x7BA1;&#x9053;&#x5316;&#x8BA1;&#x7B97;</li>
</ul>
<p><strong>3. 2D/3D Torus</strong></p>
<ul>
<li>&#x7F51;&#x683C;&#x62D3;&#x6251;&#x7684;&#x6269;&#x5C55;&#xFF0C;&#x8FB9;&#x754C;&#x8282;&#x70B9;&#x76F8;&#x8FDE;</li>
<li>&#x4F18;&#x70B9;&#xFF1A;&#x826F;&#x597D;&#x7684;&#x6269;&#x5C55;&#x6027;&#x548C;&#x5BF9;&#x79F0;&#x6027;</li>
<li>&#x7F3A;&#x70B9;&#xFF1A;&#x5E03;&#x7EBF;&#x590D;&#x6742;&#x5EA6;&#x9AD8;</li>
<li>&#x9002;&#x7528;&#x573A;&#x666F;&#xFF1A;&#x5927;&#x89C4;&#x6A21;&#x5E76;&#x884C;&#x8BA1;&#x7B97;</li>
</ul>
<p><strong>4. &#x5C42;&#x6B21;&#x5316;&#x62D3;&#x6251;&#xFF08;Hierarchical&#xFF09;</strong></p>
<ul>
<li>&#x591A;&#x7EA7;&#x4EA4;&#x6362;&#x7ED3;&#x6784;&#xFF0C;&#x5982;&#x80D6;&#x6811;&#xFF08;Fat Tree&#xFF09;</li>
<li>&#x4F18;&#x70B9;&#xFF1A;&#x53EF;&#x6269;&#x5C55;&#x5230;&#x6570;&#x767E;&#x7247;FPGA</li>
<li>&#x7F3A;&#x70B9;&#xFF1A;&#x9700;&#x8981;&#x4E13;&#x7528;&#x4EA4;&#x6362;&#x82AF;&#x7247;</li>
<li>&#x9002;&#x7528;&#x573A;&#x666F;&#xFF1A;&#x6570;&#x636E;&#x4E2D;&#x5FC3;&#x7EA7;&#x90E8;&#x7F72;</li>
</ul>
<h3 id="1712-&#x9AD8;&#x901F;&#x4E32;&#x884C;&#x94FE;&#x8DEF;&#x6280;&#x672F;">17.1.2 &#x9AD8;&#x901F;&#x4E32;&#x884C;&#x94FE;&#x8DEF;&#x6280;&#x672F;</h3>
<p>&#x73B0;&#x4EE3;FPGA&#x95F4;&#x4E92;&#x8054;&#x4E3B;&#x8981;&#x4F9D;&#x8D56;&#x9AD8;&#x901F;&#x4E32;&#x884C;&#x6536;&#x53D1;&#x5668;&#xFF08;GT&#xFF09;&#x5B9E;&#x73B0;&#xFF1A;</p>
<p><strong>GTY&#x6536;&#x53D1;&#x5668;&#x7279;&#x6027;&#xFF08;Xilinx UltraScale+&#xFF09;</strong></p>
<ul>
<li>&#x5355;&#x901A;&#x9053;&#x901F;&#x7387;&#xFF1A;&#x6700;&#x9AD8;32.75 Gbps</li>
<li>&#x652F;&#x6301;&#x534F;&#x8BAE;&#xFF1A;PCIe Gen4/5&#x3001;100G Ethernet&#x3001;Interlaken</li>
<li>&#x529F;&#x8017;&#xFF1A;&#x7EA6;150mW/&#x901A;&#x9053; @ 25Gbps</li>
<li>&#x5EF6;&#x8FDF;&#xFF1A;&lt;100ns&#xFF08;&#x5305;&#x62EC;SerDes&#x548C;&#x534F;&#x8BAE;&#x5C42;&#xFF09;</li>
</ul>
<p><strong>Aurora&#x534F;&#x8BAE;&#x4F18;&#x5316;</strong></p>
<pre><code class="lang-systemverilog">// Aurora 64B/66B &#x591A;&#x901A;&#x9053;&#x7ED1;&#x5B9A;&#x914D;&#x7F6E;
module aurora_multichannel #(
    parameter LANES = 4,
    parameter DATA_WIDTH = 256
)(
    input  wire          clk,
    input  wire [DATA_WIDTH-1:0] tx_data,
    output wire [DATA_WIDTH-1:0] rx_data,
    // GT&#x63A5;&#x53E3;&#x7701;&#x7565;
);
</code></pre>
<p>&#x5173;&#x952E;&#x8BBE;&#x8BA1;&#x8003;&#x8651;&#xFF1A;</p>
<ul>
<li>&#x901A;&#x9053;&#x7ED1;&#x5B9A;&#xFF08;Channel Bonding&#xFF09;&#x5B9E;&#x73B0;&#x66F4;&#x9AD8;&#x5E26;&#x5BBD;</li>
<li>&#x6D41;&#x63A7;&#x5236;&#x673A;&#x5236;&#x907F;&#x514D;&#x7F13;&#x51B2;&#x533A;&#x6EA2;&#x51FA;</li>
<li>CRC&#x4FDD;&#x62A4;&#x786E;&#x4FDD;&#x6570;&#x636E;&#x5B8C;&#x6574;&#x6027;</li>
<li>&#x81EA;&#x9002;&#x5E94;&#x5747;&#x8861;&#x8865;&#x507F;&#x4FE1;&#x53F7;&#x8870;&#x51CF;</li>
</ul>
<h3 id="1713-&#x5149;&#x4E92;&#x8054;&#x6280;&#x672F;">17.1.3 &#x5149;&#x4E92;&#x8054;&#x6280;&#x672F;</h3>
<p>&#x5BF9;&#x4E8E;&#x8D85;&#x5927;&#x89C4;&#x6A21;&#x7CFB;&#x7EDF;&#xFF0C;&#x5149;&#x4E92;&#x8054;&#x63D0;&#x4F9B;&#x4E86;&#x66F4;&#x4F18;&#x7684;&#x5E26;&#x5BBD;&#x5BC6;&#x5EA6;&#x548C;&#x529F;&#x8017;&#x6548;&#x7387;&#xFF1A;</p>
<p><strong>&#x7845;&#x5149;&#x5B50;&#x96C6;&#x6210;</strong></p>
<ul>
<li>&#x5355;&#x6CE2;&#x957F;&#x901F;&#x7387;&#xFF1A;50-100 Gbps</li>
<li>WDM&#x590D;&#x7528;&#xFF1A;&#x5355;&#x7EA4;&#x7EF4;&gt;1 Tbps</li>
<li>&#x4F20;&#x8F93;&#x8DDD;&#x79BB;&#xFF1A;&gt;10km&#x65E0;&#x4E2D;&#x7EE7;</li>
<li>&#x529F;&#x8017;&#xFF1A;3-5 pJ/bit</li>
</ul>
<p><strong>&#x5149;&#x7535;&#x534F;&#x540C;&#x8BBE;&#x8BA1;&#x8981;&#x70B9;</strong></p>
<ul>
<li>FPGA&#x4E0E;&#x5149;&#x6A21;&#x5757;&#x7684;&#x7D27;&#x8026;&#x5408;&#x96C6;&#x6210;</li>
<li>&#x6E29;&#x5EA6;&#x8865;&#x507F;&#x548C;&#x6CE2;&#x957F;&#x9501;&#x5B9A;</li>
<li>&#x7A81;&#x53D1;&#x6A21;&#x5F0F;&#x63A5;&#x6536;&#x5668;&#x8BBE;&#x8BA1;</li>
<li>&#x5149;&#x529F;&#x7387;&#x76D1;&#x63A7;&#x4E0E;&#x81EA;&#x52A8;&#x8C03;&#x8282;</li>
</ul>
<h3 id="1714-&#x4F4E;&#x5EF6;&#x8FDF;&#x4E92;&#x8054;&#x4F18;&#x5316;">17.1.4 &#x4F4E;&#x5EF6;&#x8FDF;&#x4E92;&#x8054;&#x4F18;&#x5316;</h3>
<p>&#x5728;&#x91D1;&#x878D;&#x4EA4;&#x6613;&#x3001;&#x5B9E;&#x65F6;&#x63A7;&#x5236;&#x7B49;&#x5E94;&#x7528;&#x4E2D;&#xFF0C;&#x4E92;&#x8054;&#x5EF6;&#x8FDF;&#x662F;&#x5173;&#x952E;&#x6307;&#x6807;&#xFF1A;</p>
<p><strong>&#x5EF6;&#x8FDF;&#x7EC4;&#x6210;&#x5206;&#x6790;</strong></p>
<ul>
<li>SerDes&#x5EF6;&#x8FDF;&#xFF1A;20-50ns</li>
<li>&#x534F;&#x8BAE;&#x5904;&#x7406;&#xFF1A;10-30ns</li>
<li>&#x8DEF;&#x7531;/&#x4EF2;&#x88C1;&#xFF1A;5-15ns</li>
<li>&#x4F20;&#x8F93;&#x5EF6;&#x8FDF;&#xFF1A;5ns/m&#xFF08;&#x7535;&#x4FE1;&#x53F7;&#xFF09;</li>
</ul>
<p><strong>&#x4F18;&#x5316;&#x7B56;&#x7565;</strong></p>
<ol>
<li><strong>&#x76F4;&#x901A;&#x6A21;&#x5F0F;&#xFF08;Cut-through&#xFF09;</strong>&#xFF1A;&#x6700;&#x5C0F;&#x5316;&#x5B58;&#x50A8;&#x8F6C;&#x53D1;&#x5EF6;&#x8FDF;</li>
<li><strong>&#x9884;&#x6D4B;&#x6027;&#x8DEF;&#x7531;</strong>&#xFF1A;&#x57FA;&#x4E8E;&#x5386;&#x53F2;&#x6A21;&#x5F0F;&#x9884;&#x6D4B;&#x76EE;&#x6807;</li>
<li><strong>&#x4E13;&#x7528;&#x4F4E;&#x5EF6;&#x8FDF;&#x534F;&#x8BAE;</strong>&#xFF1A;&#x5982;RDMA over Converged Ethernet</li>
<li><strong>&#x65F6;&#x949F;&#x540C;&#x6B65;</strong>&#xFF1A;IEEE 1588 PTP&#x5B9E;&#x73B0;&#x4E9A;&#x5FAE;&#x79D2;&#x540C;&#x6B65;</li>
</ol>
<p><strong>&#x8D85;&#x4F4E;&#x5EF6;&#x8FDF;&#x8BBE;&#x8BA1;&#x5B9E;&#x4F8B;</strong>
&#x91D1;&#x878D;&#x4EA4;&#x6613;&#x7CFB;&#x7EDF;&#x4E2D;&#x7684;&#x7EB3;&#x79D2;&#x7EA7;&#x4F18;&#x5316;&#xFF1A;</p>
<pre><code class="lang-systemverilog">// &#x786C;&#x4EF6;&#x76F4;&#x901A;&#x8DEF;&#x5F84;&#x8BBE;&#x8BA1;
module ultra_low_latency_path #(
    parameter DATA_WIDTH = 512
)(
    input  wire clk_gt,  // GT&#x65F6;&#x949F;&#x57DF;
    input  wire [DATA_WIDTH-1:0] rx_data,
    output reg  [DATA_WIDTH-1:0] tx_data,
    input  wire [15:0] filter_mask
);
    // &#x5355;&#x5468;&#x671F;&#x5224;&#x51B3;&#x903B;&#x8F91;
    wire match = (rx_data[31:16] &amp; filter_mask) == filter_mask;

    // &#x96F6;&#x62F7;&#x8D1D;&#x8F6C;&#x53D1;
    always_ff @(posedge clk_gt) begin
        if (match) begin
            tx_data &lt;= {rx_data[DATA_WIDTH-1:32], 16&apos;hDEAD, rx_data[15:0]};
        end
    end
endmodule
</code></pre>
<h3 id="1715-&#x591A;&#x534F;&#x8BAE;&#x4E92;&#x8054;&#x96C6;&#x6210;">17.1.5 &#x591A;&#x534F;&#x8BAE;&#x4E92;&#x8054;&#x96C6;&#x6210;</h3>
<p>&#x73B0;&#x4EE3;&#x591A;FPGA&#x7CFB;&#x7EDF;&#x9700;&#x8981;&#x652F;&#x6301;&#x591A;&#x79CD;&#x4E92;&#x8054;&#x534F;&#x8BAE;&#x4EE5;&#x6EE1;&#x8DB3;&#x4E0D;&#x540C;&#x573A;&#x666F;&#x9700;&#x6C42;&#xFF1A;</p>
<p><strong>&#x534F;&#x8BAE;&#x9009;&#x62E9;&#x77E9;&#x9635;</strong>
| &#x534F;&#x8BAE;&#x7C7B;&#x578B; | &#x5EF6;&#x8FDF; | &#x5E26;&#x5BBD; | &#x8DDD;&#x79BB; | &#x5E94;&#x7528;&#x573A;&#x666F; |
|---------|------|------|------|---------|
| Aurora | <100ns |="" 32.75gbps="" lane="" <10m="" 板级互联="" pcie="" gen5="" 150ns="" 32gt="" s="" <50cm="" 主机通信="" 100gbe="" 1-2μs="" 100gbps="">100km | &#x6570;&#x636E;&#x4E2D;&#x5FC3; |
| CXL | &lt;200ns | 64GB/s | &lt;30cm | &#x5185;&#x5B58;&#x6269;&#x5C55; |
| CCIX | &lt;500ns | 25Gbps/lane | &lt;5m | &#x7F13;&#x5B58;&#x4E00;&#x81F4;&#x6027; |</100ns></p>
<p><strong>&#x591A;&#x534F;&#x8BAE;&#x7F51;&#x5173;&#x8BBE;&#x8BA1;</strong></p>
<pre><code class="lang-systemverilog">// &#x534F;&#x8BAE;&#x8F6C;&#x6362;&#x7F51;&#x5173;&#x793A;&#x4F8B;
module protocol_gateway (
    // Aurora&#x63A5;&#x53E3;
    input  aurora_valid,
    input  [511:0] aurora_data,
    // PCIe&#x63A5;&#x53E3;
    output pcie_valid,
    output [255:0] pcie_data,
    // Ethernet&#x63A5;&#x53E3;
    output eth_valid,
    output [511:0] eth_data
);
    // &#x667A;&#x80FD;&#x534F;&#x8BAE;&#x9009;&#x62E9;
    always_comb begin
        case (aurora_data[15:0])  // &#x534F;&#x8BAE;&#x6807;&#x8BC6;
            16&apos;h0001: begin  // &#x8F6C;PCIe
                pcie_valid = aurora_valid;
                pcie_data = aurora_data[271:16];
            end
            16&apos;h0002: begin  // &#x8F6C;Ethernet
                eth_valid = aurora_valid;
                eth_data = aurora_data;
            end
        endcase
    end
endmodule
</code></pre>
<h3 id="1716-&#x53EF;&#x9760;&#x6027;&#x4E0E;&#x9519;&#x8BEF;&#x5904;&#x7406;">17.1.6 &#x53EF;&#x9760;&#x6027;&#x4E0E;&#x9519;&#x8BEF;&#x5904;&#x7406;</h3>
<p>&#x9AD8;&#x901F;&#x4E92;&#x8054;&#x7CFB;&#x7EDF;&#x5FC5;&#x987B;&#x5177;&#x5907;&#x5F3A;&#x5927;&#x7684;&#x9519;&#x8BEF;&#x68C0;&#x6D4B;&#x548C;&#x6062;&#x590D;&#x80FD;&#x529B;&#xFF1A;</p>
<p><strong>&#x94FE;&#x8DEF;&#x5C42;&#x9519;&#x8BEF;&#x5904;&#x7406;</strong></p>
<ol>
<li><p><strong>&#x524D;&#x5411;&#x7EA0;&#x9519;&#xFF08;FEC&#xFF09;</strong></p>
<ul>
<li>RS-FEC (544,514)&#xFF1A;&#x7EA0;&#x6B63;&#x9AD8;&#x8FBE;15&#x4E2A;&#x7B26;&#x53F7;&#x9519;&#x8BEF;</li>
<li>&#x5F00;&#x9500;&#xFF1A;5.5%&#x5E26;&#x5BBD;</li>
<li>&#x5EF6;&#x8FDF;&#x589E;&#x52A0;&#xFF1A;100-200ns</li>
</ul>
</li>
<li><p><strong>&#x81EA;&#x9002;&#x5E94;&#x91CD;&#x4F20;&#x673A;&#x5236;</strong></p>
<pre><code class="lang-systemverilog">// &#x9009;&#x62E9;&#x6027;&#x91CD;&#x4F20;&#x7F13;&#x51B2;&#x533A;
module selective_retrans_buffer #(
    parameter DEPTH = 1024,
    parameter WIDTH = 512
)(
    input  clk,
    input  [WIDTH-1:0] tx_data,
    input  tx_valid,
    input  [9:0] ack_seq,
    input  [9:0] nack_seq,
    output [WIDTH-1:0] retrans_data
);
    // &#x5FAA;&#x73AF;&#x7F13;&#x51B2;&#x533A;&#x5B58;&#x50A8;&#x5DF2;&#x53D1;&#x9001;&#x6570;&#x636E;
    reg [WIDTH-1:0] buffer [DEPTH-1:0];
    reg [9:0] wr_ptr, rd_ptr;

    // NACK&#x89E6;&#x53D1;&#x91CD;&#x4F20;
    always_ff @(posedge clk) begin
        if (nack_seq != ack_seq) begin
            rd_ptr &lt;= nack_seq;
            // &#x89E6;&#x53D1;&#x91CD;&#x4F20;&#x72B6;&#x6001;&#x673A;
        end
    end
endmodule
</code></pre>
</li>
<li><p><strong>&#x94FE;&#x8DEF;&#x5065;&#x5EB7;&#x76D1;&#x63A7;</strong></p>
<ul>
<li>&#x8BEF;&#x7801;&#x7387;&#x5B9E;&#x65F6;&#x7EDF;&#x8BA1;</li>
<li>&#x4FE1;&#x53F7;&#x8D28;&#x91CF;&#x6307;&#x6807;&#xFF08;&#x773C;&#x56FE;&#x88D5;&#x91CF;&#xFF09;</li>
<li>&#x81EA;&#x52A8;&#x964D;&#x901F;/&#x91CD;&#x8BAD;&#x7EC3;</li>
<li>&#x6545;&#x969C;&#x94FE;&#x8DEF;&#x9694;&#x79BB;</li>
</ul>
</li>
</ol>
<p><strong>&#x7AEF;&#x5230;&#x7AEF;&#x53EF;&#x9760;&#x6027;&#x4FDD;&#x8BC1;</strong></p>
<ul>
<li>&#x6D88;&#x606F;&#x5E8F;&#x53F7;&#x548C;&#x786E;&#x8BA4;&#x673A;&#x5236;</li>
<li>&#x8D85;&#x65F6;&#x91CD;&#x4F20;&#x7B56;&#x7565;</li>
<li>&#x6D41;&#x91CF;&#x63A7;&#x5236;&#x907F;&#x514D;&#x7F13;&#x51B2;&#x533A;&#x6EA2;&#x51FA;</li>
<li>&#x7AEF;&#x5230;&#x7AEF;CRC&#x6821;&#x9A8C;</li>
</ul>
<h2 id="172-&#x5206;&#x5E03;&#x5F0F;&#x8BA1;&#x7B97;&#x6A21;&#x578B;">17.2 &#x5206;&#x5E03;&#x5F0F;&#x8BA1;&#x7B97;&#x6A21;&#x578B;</h2>
<h3 id="1721-&#x4EFB;&#x52A1;&#x5206;&#x89E3;&#x4E0E;&#x6620;&#x5C04;">17.2.1 &#x4EFB;&#x52A1;&#x5206;&#x89E3;&#x4E0E;&#x6620;&#x5C04;</h3>
<p>&#x5C06;&#x5927;&#x89C4;&#x6A21;&#x8BA1;&#x7B97;&#x4EFB;&#x52A1;&#x9AD8;&#x6548;&#x6620;&#x5C04;&#x5230;&#x591A;FPGA&#x7CFB;&#x7EDF;&#x662F;&#x5B9E;&#x73B0;&#x6027;&#x80FD;&#x6269;&#x5C55;&#x7684;&#x5173;&#x952E;&#xFF1A;</p>
<p><strong>&#x7A7A;&#x95F4;&#x5206;&#x89E3;&#xFF08;Spatial Decomposition&#xFF09;</strong></p>
<ul>
<li>&#x6570;&#x636E;&#x5E76;&#x884C;&#xFF1A;&#x6BCF;&#x4E2A;FPGA&#x5904;&#x7406;&#x6570;&#x636E;&#x7684;&#x4E0D;&#x540C;&#x90E8;&#x5206;</li>
<li>&#x6A21;&#x578B;&#x5E76;&#x884C;&#xFF1A;&#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x5C42;&#x5206;&#x5E03;&#x5230;&#x4E0D;&#x540C;FPGA</li>
<li>&#x6DF7;&#x5408;&#x5E76;&#x884C;&#xFF1A;&#x7ED3;&#x5408;&#x6570;&#x636E;&#x548C;&#x6A21;&#x578B;&#x5E76;&#x884C;</li>
</ul>
<p><strong>&#x65F6;&#x95F4;&#x5206;&#x89E3;&#xFF08;Temporal Decomposition&#xFF09;</strong></p>
<ul>
<li>&#x6D41;&#x6C34;&#x7EBF;&#x5E76;&#x884C;&#xFF1A;&#x4E0D;&#x540C;FPGA&#x8D1F;&#x8D23;&#x4E0D;&#x540C;&#x5904;&#x7406;&#x9636;&#x6BB5;</li>
<li>&#x4EFB;&#x52A1;&#x7EA7;&#x5E76;&#x884C;&#xFF1A;&#x72EC;&#x7ACB;&#x4EFB;&#x52A1;&#x5206;&#x914D;&#x5230;&#x4E0D;&#x540C;FPGA</li>
<li>&#x52A8;&#x6001;&#x8C03;&#x5EA6;&#xFF1A;&#x8FD0;&#x884C;&#x65F6;&#x4EFB;&#x52A1;&#x8FC1;&#x79FB;&#x548C;&#x8D1F;&#x8F7D;&#x5747;&#x8861;</li>
</ul>
<h3 id="1722-&#x5206;&#x5E03;&#x5F0F;ai&#x63A8;&#x7406;&#x67B6;&#x6784;">17.2.2 &#x5206;&#x5E03;&#x5F0F;AI&#x63A8;&#x7406;&#x67B6;&#x6784;</h3>
<p>&#x4EE5;&#x5927;&#x8BED;&#x8A00;&#x6A21;&#x578B;&#x63A8;&#x7406;&#x4E3A;&#x4F8B;&#xFF0C;&#x5C55;&#x793A;&#x591A;FPGA&#x534F;&#x540C;&#x5DE5;&#x4F5C;&#x6A21;&#x5F0F;&#xFF1A;</p>
<p><strong>&#x6A21;&#x578B;&#x5206;&#x7247;&#x7B56;&#x7565;</strong></p>
<pre><code>LLM&#x603B;&#x53C2;&#x6570;&#xFF1A;175B
&#x5355;FPGA&#x5BB9;&#x91CF;&#xFF1A;16GB HBM
&#x5206;&#x7247;&#x65B9;&#x6848;&#xFF1A;
- Transformer&#x5C42;&#x95F4;&#x5206;&#x7247;&#xFF1A;&#x6BCF;FPGA&#x8D1F;&#x8D23;2-3&#x5C42;
- &#x6CE8;&#x610F;&#x529B;&#x5934;&#x5E76;&#x884C;&#xFF1A;64&#x5934;&#x5206;&#x5E03;&#x5230;8&#x4E2A;FPGA
- FFN&#x5217;&#x5207;&#x5206;&#xFF1A;&#x9690;&#x85CF;&#x5C42;16K&#x7EF4;&#x5EA6;&#x5207;&#x5206;&#x4E3A;2K&#xD7;8
</code></pre><p><strong>&#x63A8;&#x7406;&#x6D41;&#x6C34;&#x7EBF;&#x8BBE;&#x8BA1;</strong></p>
<ol>
<li><p><strong>Token&#x5D4C;&#x5165;&#x9636;&#x6BB5;</strong>&#xFF08;FPGA 0&#xFF09;</p>
<ul>
<li>&#x8BCD;&#x8868;&#x67E5;&#x627E;&#x548C;&#x4F4D;&#x7F6E;&#x7F16;&#x7801;</li>
<li>&#x6279;&#x5904;&#x7406;token&#x6253;&#x5305;</li>
<li>&#x5E7F;&#x64AD;&#x5230;&#x8BA1;&#x7B97;&#x8282;&#x70B9;</li>
</ul>
</li>
<li><p><strong>Transformer&#x8BA1;&#x7B97;</strong>&#xFF08;FPGA 1-14&#xFF09;</p>
<ul>
<li>&#x6BCF;FPGA&#x8D1F;&#x8D23;6&#x5C42;Transformer</li>
<li>&#x5C42;&#x95F4;&#x91C7;&#x7528;&#x6D41;&#x6C34;&#x7EBF;&#x4F20;&#x8F93;</li>
<li>KV&#x7F13;&#x5B58;&#x672C;&#x5730;&#x5B58;&#x50A8;</li>
</ul>
</li>
<li><p><strong>&#x8F93;&#x51FA;&#x6295;&#x5F71;</strong>&#xFF08;FPGA 15&#xFF09;</p>
<ul>
<li>&#x6700;&#x7EC8;&#x5C42;&#x5F52;&#x4E00;&#x5316;</li>
<li>&#x8BCD;&#x8868;&#x6295;&#x5F71;&#x548C;&#x91C7;&#x6837;</li>
<li>&#x7ED3;&#x679C;&#x6536;&#x96C6;&#x548C;&#x8FD4;&#x56DE;</li>
</ul>
</li>
</ol>
<h3 id="1723-&#x901A;&#x4FE1;&#x6A21;&#x5F0F;&#x4E0E;&#x4F18;&#x5316;">17.2.3 &#x901A;&#x4FE1;&#x6A21;&#x5F0F;&#x4E0E;&#x4F18;&#x5316;</h3>
<p><strong>&#x96C6;&#x5408;&#x901A;&#x4FE1;&#x539F;&#x8BED;</strong></p>
<ul>
<li><strong>All-Reduce</strong>&#xFF1A;&#x53C2;&#x6570;&#x805A;&#x5408;&#xFF0C;&#x5982;&#x68AF;&#x5EA6;&#x540C;&#x6B65;</li>
<li><strong>All-Gather</strong>&#xFF1A;&#x6536;&#x96C6;&#x5206;&#x5E03;&#x5F0F;&#x8BA1;&#x7B97;&#x7ED3;&#x679C;</li>
<li><strong>Broadcast</strong>&#xFF1A;&#x6A21;&#x578B;&#x53C2;&#x6570;&#x5206;&#x53D1;</li>
<li><strong>Reduce-Scatter</strong>&#xFF1A;&#x5206;&#x5E03;&#x5F0F;&#x5F52;&#x7EA6;</li>
</ul>
<p><strong>&#x901A;&#x4FE1;&#x4F18;&#x5316;&#x6280;&#x672F;</strong></p>
<ol>
<li><p><strong>&#x91CD;&#x53E0;&#x8BA1;&#x7B97;&#x4E0E;&#x901A;&#x4FE1;</strong></p>
<pre><code class="lang-systemverilog">// &#x53CC;&#x7F13;&#x51B2;&#x5B9E;&#x73B0;&#x8BA1;&#x7B97;&#x901A;&#x4FE1;&#x91CD;&#x53E0;
always_ff @(posedge clk) begin
    if (compute_done[buf_idx]) begin
        start_transfer[buf_idx] &lt;= 1&apos;b1;
        buf_idx &lt;= ~buf_idx;  // &#x5207;&#x6362;&#x7F13;&#x51B2;&#x533A;
    end
end
</code></pre>
</li>
<li><p><strong>&#x901A;&#x4FE1;&#x538B;&#x7F29;</strong></p>
<ul>
<li>&#x68AF;&#x5EA6;&#x91CF;&#x5316;&#xFF1A;FP32&#x2192;INT8</li>
<li>&#x7A00;&#x758F;&#x5316;&#x4F20;&#x8F93;&#xFF1A;&#x53EA;&#x4F20;&#x975E;&#x96F6;&#x503C;</li>
<li>&#x5DEE;&#x5206;&#x7F16;&#x7801;&#xFF1A;&#x4F20;&#x8F93;&#x589E;&#x91CF;</li>
</ul>
</li>
<li><p><strong>&#x62D3;&#x6251;&#x611F;&#x77E5;&#x8DEF;&#x7531;</strong></p>
<ul>
<li>&#x6700;&#x77ED;&#x8DEF;&#x5F84;&#x4F18;&#x5148;</li>
<li>&#x8D1F;&#x8F7D;&#x5747;&#x8861;&#x8DEF;&#x7531;</li>
<li>&#x62E5;&#x585E;&#x907F;&#x514D;&#x673A;&#x5236;</li>
</ul>
</li>
</ol>
<h3 id="1724-&#x5206;&#x5E03;&#x5F0F;&#x5B58;&#x50A8;&#x7BA1;&#x7406;">17.2.4 &#x5206;&#x5E03;&#x5F0F;&#x5B58;&#x50A8;&#x7BA1;&#x7406;</h3>
<p><strong>&#x5B58;&#x50A8;&#x5C42;&#x6B21;&#x7ED3;&#x6784;</strong></p>
<pre><code>L1: &#x7247;&#x4E0A;BRAM/URAM (10-100MB, &lt;5ns)
L2: HBM/DDR4 (16-32GB, 100-200ns)
L3: NVMe SSD (TB&#x7EA7;, 10-100&#x3BC;s)
L4: &#x8FDC;&#x7A0B;&#x5B58;&#x50A8; (PB&#x7EA7;, ms&#x7EA7;)
</code></pre><p><strong>&#x6570;&#x636E;&#x653E;&#x7F6E;&#x7B56;&#x7565;</strong></p>
<ul>
<li>&#x70ED;&#x70B9;&#x6570;&#x636E;&#x590D;&#x5236;&#x5230;&#x591A;&#x8282;&#x70B9;</li>
<li>&#x51B7;&#x6570;&#x636E;&#x5206;&#x7247;&#x5B58;&#x50A8;</li>
<li>&#x9884;&#x53D6;&#x548C;&#x7F13;&#x5B58;&#x7BA1;&#x7406;</li>
<li>&#x4E00;&#x81F4;&#x6027;&#x54C8;&#x5E0C;&#x5206;&#x5E03;</li>
</ul>
<h3 id="1725-&#x5BB9;&#x9519;&#x4E0E;&#x53EF;&#x9760;&#x6027;">17.2.5 &#x5BB9;&#x9519;&#x4E0E;&#x53EF;&#x9760;&#x6027;</h3>
<p>&#x5206;&#x5E03;&#x5F0F;&#x7CFB;&#x7EDF;&#x5FC5;&#x987B;&#x8003;&#x8651;&#x8282;&#x70B9;&#x6545;&#x969C;&#x548C;&#x901A;&#x4FE1;&#x9519;&#x8BEF;&#xFF1A;</p>
<p><strong>&#x68C0;&#x67E5;&#x70B9;&#x673A;&#x5236;</strong></p>
<ul>
<li>&#x5468;&#x671F;&#x6027;&#x4FDD;&#x5B58;&#x7CFB;&#x7EDF;&#x72B6;&#x6001;</li>
<li>&#x589E;&#x91CF;&#x68C0;&#x67E5;&#x70B9;&#x51CF;&#x5C11;&#x5F00;&#x9500;</li>
<li>&#x5F02;&#x6B65;&#x68C0;&#x67E5;&#x70B9;&#x907F;&#x514D;&#x963B;&#x585E;</li>
</ul>
<p><strong>&#x6545;&#x969C;&#x68C0;&#x6D4B;&#x4E0E;&#x6062;&#x590D;</strong></p>
<ul>
<li>&#x5FC3;&#x8DF3;&#x76D1;&#x63A7;&#x8282;&#x70B9;&#x72B6;&#x6001;</li>
<li>&#x5FEB;&#x901F;&#x6545;&#x969C;&#x5207;&#x6362;&#xFF08;&lt;1s&#xFF09;</li>
<li>&#x4EFB;&#x52A1;&#x91CD;&#x65B0;&#x8C03;&#x5EA6;</li>
<li>&#x6570;&#x636E;&#x91CD;&#x5EFA;&#x548C;&#x4FEE;&#x590D;</li>
</ul>
<p><strong>Byzantine&#x5BB9;&#x9519;</strong>
&#x5BF9;&#x4E8E;&#x5173;&#x952E;&#x5E94;&#x7528;&#xFF0C;&#x9700;&#x8981;&#x8003;&#x8651;&#x62DC;&#x5360;&#x5EAD;&#x6545;&#x969C;&#xFF1A;</p>
<ul>
<li>&#x591A;&#x6570;&#x6295;&#x7968;&#x673A;&#x5236;</li>
<li>&#x72B6;&#x6001;&#x673A;&#x590D;&#x5236;</li>
<li>&#x53EF;&#x9A8C;&#x8BC1;&#x8BA1;&#x7B97;</li>
</ul>
<p><strong>&#x5206;&#x5E03;&#x5F0F;&#x68C0;&#x67E5;&#x70B9;&#x5B9E;&#x73B0;</strong></p>
<pre><code class="lang-systemverilog">module distributed_checkpoint #(
    parameter NODE_ID = 0,
    parameter STATE_WIDTH = 1024,
    parameter CHECKPOINT_INTERVAL = 1000000  // &#x65F6;&#x949F;&#x5468;&#x671F;
)(
    input  clk,
    input  rst_n,
    input  [STATE_WIDTH-1:0] current_state,
    output reg checkpoint_trigger,
    output reg [STATE_WIDTH-1:0] checkpoint_data
);
    reg [31:0] interval_counter;
    reg [STATE_WIDTH-1:0] shadow_state;

    // Chandy-Lamport&#x7B97;&#x6CD5;&#x5B9E;&#x73B0;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            interval_counter &lt;= 0;
        end else begin
            interval_counter &lt;= interval_counter + 1;
            if (interval_counter == CHECKPOINT_INTERVAL) begin
                checkpoint_trigger &lt;= 1&apos;b1;
                shadow_state &lt;= current_state;
                // &#x53D1;&#x9001;&#x6807;&#x8BB0;&#x6D88;&#x606F;&#x5230;&#x6240;&#x6709;&#x901A;&#x9053;
            end
        end
    end
endmodule
</code></pre>
<h3 id="1726-&#x8D1F;&#x8F7D;&#x5747;&#x8861;&#x7B56;&#x7565;">17.2.6 &#x8D1F;&#x8F7D;&#x5747;&#x8861;&#x7B56;&#x7565;</h3>
<p>&#x6709;&#x6548;&#x7684;&#x8D1F;&#x8F7D;&#x5747;&#x8861;&#x662F;&#x5B9E;&#x73B0;&#x7EBF;&#x6027;&#x6269;&#x5C55;&#x7684;&#x5173;&#x952E;&#xFF1A;</p>
<p><strong>&#x9759;&#x6001;&#x8D1F;&#x8F7D;&#x5747;&#x8861;</strong></p>
<ol>
<li><p><strong>&#x8F6E;&#x8BE2;&#x5206;&#x914D;&#xFF08;Round-Robin&#xFF09;</strong></p>
<ul>
<li>&#x7B80;&#x5355;&#x516C;&#x5E73;&#xFF0C;&#x9002;&#x5408;&#x540C;&#x6784;&#x4EFB;&#x52A1;</li>
<li>&#x65E0;&#x9700;&#x8FD0;&#x884C;&#x65F6;&#x5F00;&#x9500;</li>
</ul>
</li>
<li><p><strong>&#x54C8;&#x5E0C;&#x5206;&#x914D;</strong></p>
<ul>
<li>&#x57FA;&#x4E8E;&#x6570;&#x636E;&#x7279;&#x5F81;&#x5206;&#x914D;</li>
<li>&#x4FDD;&#x8BC1;&#x76F8;&#x540C;&#x6570;&#x636E;&#x5230;&#x540C;&#x4E00;&#x8282;&#x70B9;</li>
</ul>
</li>
<li><p><strong>&#x8303;&#x56F4;&#x5206;&#x7247;</strong></p>
<ul>
<li>&#x6309;&#x6570;&#x636E;&#x8303;&#x56F4;&#x5212;&#x5206;</li>
<li>&#x4FBF;&#x4E8E;&#x8303;&#x56F4;&#x67E5;&#x8BE2;&#x4F18;&#x5316;</li>
</ul>
</li>
</ol>
<p><strong>&#x52A8;&#x6001;&#x8D1F;&#x8F7D;&#x5747;&#x8861;</strong></p>
<pre><code class="lang-systemverilog">// &#x5DE5;&#x4F5C;&#x7A83;&#x53D6;&#x961F;&#x5217;&#x5B9E;&#x73B0;
module work_stealing_queue #(
    parameter TASK_WIDTH = 128,
    parameter QUEUE_DEPTH = 256
)(
    input  clk,
    input  rst_n,
    // &#x672C;&#x5730;&#x63A5;&#x53E3;
    input  local_push,
    input  [TASK_WIDTH-1:0] local_task,
    output local_pop,
    output [TASK_WIDTH-1:0] local_data,
    // &#x7A83;&#x53D6;&#x63A5;&#x53E3;
    input  steal_req,
    output steal_ack,
    output [TASK_WIDTH-1:0] steal_data
);
    // &#x53CC;&#x7AEF;&#x961F;&#x5217;&#x5B9E;&#x73B0;
    reg [TASK_WIDTH-1:0] queue [QUEUE_DEPTH-1:0];
    reg [7:0] head, tail;

    // &#x672C;&#x5730;&#x4EFB;&#x52A1;&#x4ECE;&#x5C3E;&#x90E8;&#x63D2;&#x5165;
    always_ff @(posedge clk) begin
        if (local_push &amp;&amp; !full) begin
            queue[tail] &lt;= local_task;
            tail &lt;= tail + 1;
        end
    end

    // &#x7A83;&#x53D6;&#x4ECE;&#x5934;&#x90E8;&#x83B7;&#x53D6;
    always_ff @(posedge clk) begin
        if (steal_req &amp;&amp; !empty) begin
            steal_data &lt;= queue[head];
            head &lt;= head + 1;
            steal_ack &lt;= 1&apos;b1;
        end
    end
endmodule
</code></pre>
<p><strong>&#x8D1F;&#x8F7D;&#x76D1;&#x63A7;&#x4E0E;&#x8FC1;&#x79FB;</strong></p>
<ul>
<li>&#x5B9E;&#x65F6;&#x8D1F;&#x8F7D;&#x6307;&#x6807;&#x6536;&#x96C6;</li>
<li>&#x9884;&#x6D4B;&#x6027;&#x8D1F;&#x8F7D;&#x8BC4;&#x4F30;</li>
<li>&#x6700;&#x5C0F;&#x5316;&#x8FC1;&#x79FB;&#x5F00;&#x9500;</li>
<li>&#x4EB2;&#x548C;&#x6027;&#x4FDD;&#x6301;</li>
</ul>
<h3 id="1727-&#x5206;&#x5E03;&#x5F0F;&#x8C03;&#x5EA6;&#x6846;&#x67B6;">17.2.7 &#x5206;&#x5E03;&#x5F0F;&#x8C03;&#x5EA6;&#x6846;&#x67B6;</h3>
<p><strong>&#x5C42;&#x6B21;&#x5316;&#x8C03;&#x5EA6;&#x5668;</strong></p>
<pre><code>&#x5168;&#x5C40;&#x8C03;&#x5EA6;&#x5668;&#xFF08;Master&#xFF09;
&#x251C;&#x2500;&#x2500; &#x533A;&#x57DF;&#x8C03;&#x5EA6;&#x5668;1&#xFF08;Zone1&#xFF09;
&#x2502;   &#x251C;&#x2500;&#x2500; &#x8282;&#x70B9;&#x8C03;&#x5EA6;&#x5668;1
&#x2502;   &#x2514;&#x2500;&#x2500; &#x8282;&#x70B9;&#x8C03;&#x5EA6;&#x5668;2
&#x2514;&#x2500;&#x2500; &#x533A;&#x57DF;&#x8C03;&#x5EA6;&#x5668;2&#xFF08;Zone2&#xFF09;
    &#x251C;&#x2500;&#x2500; &#x8282;&#x70B9;&#x8C03;&#x5EA6;&#x5668;3
    &#x2514;&#x2500;&#x2500; &#x8282;&#x70B9;&#x8C03;&#x5EA6;&#x5668;4
</code></pre><p><strong>&#x8C03;&#x5EA6;&#x7B56;&#x7565;&#x5B9E;&#x73B0;</strong></p>
<ol>
<li><p><strong>&#x4F18;&#x5148;&#x7EA7;&#x8C03;&#x5EA6;</strong></p>
<ul>
<li>&#x591A;&#x7EA7;&#x53CD;&#x9988;&#x961F;&#x5217;</li>
<li>&#x9965;&#x997F;&#x907F;&#x514D;&#x673A;&#x5236;</li>
<li>QoS&#x4FDD;&#x8BC1;</li>
</ul>
</li>
<li><p><strong>&#x4EB2;&#x548C;&#x6027;&#x8C03;&#x5EA6;</strong></p>
<ul>
<li>&#x6570;&#x636E;&#x5C40;&#x90E8;&#x6027;&#x4F18;&#x5316;</li>
<li>&#x7F13;&#x5B58;&#x53CB;&#x597D;&#x5206;&#x914D;</li>
<li>NUMA&#x611F;&#x77E5;</li>
</ul>
</li>
<li><p><strong>&#x80FD;&#x6548;&#x8C03;&#x5EA6;</strong></p>
<ul>
<li>DVFS&#x63A7;&#x5236;</li>
<li>&#x4EFB;&#x52A1;&#x6253;&#x5305;&#x4F18;&#x5316;</li>
<li>&#x7A7A;&#x95F2;&#x8282;&#x70B9;&#x4F11;&#x7720;</li>
</ul>
</li>
</ol>
<h3 id="1728-&#x5206;&#x5E03;&#x5F0F;&#x540C;&#x6B65;&#x4F18;&#x5316;">17.2.8 &#x5206;&#x5E03;&#x5F0F;&#x540C;&#x6B65;&#x4F18;&#x5316;</h3>
<p><strong>&#x65E0;&#x9501;&#x6570;&#x636E;&#x7ED3;&#x6784;</strong></p>
<pre><code class="lang-systemverilog">// &#x65E0;&#x9501;FIFO&#x5B9E;&#x73B0;
module lock_free_fifo #(
    parameter DATA_WIDTH = 64,
    parameter ADDR_WIDTH = 10
)(
    input  clk,
    // &#x751F;&#x4EA7;&#x8005;&#x63A5;&#x53E3;
    input  prod_valid,
    input  [DATA_WIDTH-1:0] prod_data,
    output prod_ready,
    // &#x6D88;&#x8D39;&#x8005;&#x63A5;&#x53E3;
    output cons_valid,
    output [DATA_WIDTH-1:0] cons_data,
    input  cons_ready
);
    // &#x4F7F;&#x7528;&#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x7684;&#x5934;&#x5C3E;&#x6307;&#x9488;
    reg [ADDR_WIDTH-1:0] head, tail;
    reg [DATA_WIDTH-1:0] buffer [(1&lt;&lt;ADDR_WIDTH)-1:0];

    // &#x5355;&#x751F;&#x4EA7;&#x8005;&#x5355;&#x6D88;&#x8D39;&#x8005;&#x4F18;&#x5316;
    wire empty = (head == tail);
    wire full = ((tail + 1) &amp; ((1&lt;&lt;ADDR_WIDTH)-1)) == head;

    assign prod_ready = !full;
    assign cons_valid = !empty;
endmodule
</code></pre>
<p><strong>&#x5206;&#x5E03;&#x5F0F;&#x4E8B;&#x52A1;&#x652F;&#x6301;</strong></p>
<ul>
<li>&#x4E24;&#x9636;&#x6BB5;&#x63D0;&#x4EA4;&#x534F;&#x8BAE;</li>
<li>&#x4E09;&#x9636;&#x6BB5;&#x63D0;&#x4EA4;&#x4F18;&#x5316;</li>
<li>&#x8865;&#x507F;&#x4E8B;&#x52A1;&#x673A;&#x5236;</li>
<li>&#x5206;&#x5E03;&#x5F0F;&#x9501;&#x670D;&#x52A1;</li>
</ul>
<h2 id="173-&#x6570;&#x636E;&#x4E00;&#x81F4;&#x6027;&#x4E0E;&#x540C;&#x6B65;">17.3 &#x6570;&#x636E;&#x4E00;&#x81F4;&#x6027;&#x4E0E;&#x540C;&#x6B65;</h2>
<h3 id="1731-&#x4E00;&#x81F4;&#x6027;&#x6A21;&#x578B;">17.3.1 &#x4E00;&#x81F4;&#x6027;&#x6A21;&#x578B;</h3>
<p>&#x591A;FPGA&#x7CFB;&#x7EDF;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x4E00;&#x81F4;&#x6027;&#x662F;&#x786E;&#x4FDD;&#x8BA1;&#x7B97;&#x6B63;&#x786E;&#x6027;&#x7684;&#x57FA;&#x7840;&#xFF1A;</p>
<p><strong>&#x5F3A;&#x4E00;&#x81F4;&#x6027;&#xFF08;Strong Consistency&#xFF09;</strong></p>
<ul>
<li>&#x6240;&#x6709;&#x8282;&#x70B9;&#x770B;&#x5230;&#x76F8;&#x540C;&#x7684;&#x6570;&#x636E;&#x987A;&#x5E8F;</li>
<li>&#x5B9E;&#x73B0;&#x4EE3;&#x4EF7;&#x9AD8;&#xFF0C;&#x5EF6;&#x8FDF;&#x5927;</li>
<li>&#x9002;&#x7528;&#xFF1A;&#x91D1;&#x878D;&#x4EA4;&#x6613;&#x3001;&#x6570;&#x636E;&#x5E93;</li>
</ul>
<p><strong>&#x6700;&#x7EC8;&#x4E00;&#x81F4;&#x6027;&#xFF08;Eventual Consistency&#xFF09;</strong></p>
<ul>
<li>&#x5141;&#x8BB8;&#x6682;&#x65F6;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x6700;&#x7EC8;&#x6536;&#x655B;</li>
<li>&#x6027;&#x80FD;&#x597D;&#xFF0C;&#x9002;&#x5408;&#x5206;&#x5E03;&#x5F0F;AI&#x8BAD;&#x7EC3;</li>
<li>&#x5B9E;&#x73B0;&#xFF1A;&#x5411;&#x91CF;&#x65F6;&#x949F;&#x3001;CRDT</li>
</ul>
<p><strong>&#x56E0;&#x679C;&#x4E00;&#x81F4;&#x6027;&#xFF08;Causal Consistency&#xFF09;</strong></p>
<ul>
<li>&#x4FDD;&#x8BC1;&#x56E0;&#x679C;&#x76F8;&#x5173;&#x64CD;&#x4F5C;&#x7684;&#x987A;&#x5E8F;</li>
<li>&#x5E73;&#x8861;&#x6027;&#x80FD;&#x548C;&#x6B63;&#x786E;&#x6027;</li>
<li>&#x9002;&#x7528;&#xFF1A;&#x5206;&#x5E03;&#x5F0F;&#x63A8;&#x7406;&#x7CFB;&#x7EDF;</li>
</ul>
<h3 id="1732-&#x540C;&#x6B65;&#x539F;&#x8BED;&#x5B9E;&#x73B0;">17.3.2 &#x540C;&#x6B65;&#x539F;&#x8BED;&#x5B9E;&#x73B0;</h3>
<p><strong>&#x5206;&#x5E03;&#x5F0F;&#x5C4F;&#x969C;&#xFF08;Barrier&#xFF09;</strong></p>
<pre><code class="lang-systemverilog">module distributed_barrier #(
    parameter NUM_NODES = 16,
    parameter TIMEOUT = 1000000  // &#x65F6;&#x949F;&#x5468;&#x671F;
)(
    input  wire clk,
    input  wire rst_n,
    input  wire local_ready,
    output wire all_ready,
    // &#x7F51;&#x7EDC;&#x63A5;&#x53E3;
    output wire [NUM_NODES-1:0] barrier_req,
    input  wire [NUM_NODES-1:0] barrier_ack
);

    reg [NUM_NODES-1:0] node_ready;
    reg [31:0] timeout_cnt;

    // &#x8776;&#x5F62;&#x7F51;&#x7EDC;&#x5B9E;&#x73B0;&#x5168;&#x5C40;&#x540C;&#x6B65;
    genvar i;
    generate
        for (i = 0; i &lt; $clog2(NUM_NODES); i++) begin
            // &#x6BCF;&#x5C42;&#x4EA4;&#x6362;&#x4FE1;&#x606F;
        end
    endgenerate
endmodule
</code></pre>
<p><strong>&#x5206;&#x5E03;&#x5F0F;&#x9501;&#x670D;&#x52A1;</strong></p>
<ul>
<li>&#x57FA;&#x4E8E;Paxos/Raft&#x7684;&#x5206;&#x5E03;&#x5F0F;&#x5171;&#x8BC6;</li>
<li>&#x79DF;&#x7EA6;&#x673A;&#x5236;&#x907F;&#x514D;&#x6B7B;&#x9501;</li>
<li>&#x4F18;&#x5148;&#x7EA7;&#x652F;&#x6301;&#x907F;&#x514D;&#x9965;&#x997F;</li>
</ul>
<h3 id="1733-&#x7F13;&#x5B58;&#x4E00;&#x81F4;&#x6027;&#x534F;&#x8BAE;">17.3.3 &#x7F13;&#x5B58;&#x4E00;&#x81F4;&#x6027;&#x534F;&#x8BAE;</h3>
<p><strong>&#x76EE;&#x5F55;&#x5F0F;&#x534F;&#x8BAE;&#xFF08;Directory-based&#xFF09;</strong>
&#x9002;&#x7528;&#x4E8E;FPGA&#x96C6;&#x7FA4;&#x7684;&#x7F13;&#x5B58;&#x4E00;&#x81F4;&#x6027;&#xFF1A;</p>
<pre><code>&#x72B6;&#x6001;&#x673A;&#xFF1A;
- Invalid (I): &#x65E0;&#x6548;&#x6570;&#x636E;
- Shared (S): &#x5171;&#x4EAB;&#x53EA;&#x8BFB;
- Modified (M): &#x72EC;&#x5360;&#x4FEE;&#x6539;
- Exclusive (E): &#x72EC;&#x5360;&#x672A;&#x4FEE;&#x6539;

&#x76EE;&#x5F55;&#x9879;&#xFF1A;
- Owner: &#x6570;&#x636E;&#x62E5;&#x6709;&#x8005;ID
- Sharers: &#x5171;&#x4EAB;&#x8005;&#x4F4D;&#x56FE;
- State: &#x5F53;&#x524D;&#x72B6;&#x6001;
</code></pre><p><strong>&#x76D1;&#x542C;&#x5F0F;&#x534F;&#x8BAE;&#x4F18;&#x5316;</strong></p>
<ul>
<li>&#x5E7F;&#x64AD;&#x57DF;&#x9650;&#x5236;&#xFF1A;&#x5206;&#x5C42;&#x76D1;&#x542C;</li>
<li>&#x8FC7;&#x6EE4;&#x673A;&#x5236;&#xFF1A;&#x51CF;&#x5C11;&#x65E0;&#x6548;&#x76D1;&#x542C;</li>
<li>&#x9884;&#x6D4B;&#x6027;&#x9884;&#x53D6;&#xFF1A;&#x57FA;&#x4E8E;&#x8BBF;&#x95EE;&#x6A21;&#x5F0F;</li>
</ul>
<h3 id="1734-&#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x652F;&#x6301;">17.3.4 &#x539F;&#x5B50;&#x64CD;&#x4F5C;&#x652F;&#x6301;</h3>
<p><strong>&#x5206;&#x5E03;&#x5F0F;&#x539F;&#x5B50;&#x64CD;&#x4F5C;</strong></p>
<pre><code class="lang-systemverilog">// &#x5206;&#x5E03;&#x5F0F;&#x6BD4;&#x8F83;&#x4EA4;&#x6362;&#x5B9E;&#x73B0;
module distributed_cas #(
    parameter DATA_WIDTH = 64,
    parameter ADDR_WIDTH = 48
)(
    input  wire clk,
    input  wire [ADDR_WIDTH-1:0] addr,
    input  wire [DATA_WIDTH-1:0] expected,
    input  wire [DATA_WIDTH-1:0] new_val,
    output reg  success,
    output reg  [DATA_WIDTH-1:0] old_val
);
</code></pre>
<p>&#x5173;&#x952E;&#x7279;&#x6027;&#xFF1A;</p>
<ul>
<li>&#x4E24;&#x9636;&#x6BB5;&#x63D0;&#x4EA4;&#x4FDD;&#x8BC1;&#x539F;&#x5B50;&#x6027;</li>
<li>&#x7248;&#x672C;&#x53F7;&#x907F;&#x514D;ABA&#x95EE;&#x9898;</li>
<li>&#x786C;&#x4EF6;&#x961F;&#x5217;&#x7BA1;&#x7406;&#x51B2;&#x7A81;</li>
</ul>
<h3 id="1735-&#x5185;&#x5B58;&#x5E8F;&#x6A21;&#x578B;">17.3.5 &#x5185;&#x5B58;&#x5E8F;&#x6A21;&#x578B;</h3>
<p><strong>&#x677E;&#x5F1B;&#x5185;&#x5B58;&#x5E8F;&#xFF08;Relaxed Memory Order&#xFF09;</strong>
FPGA&#x7CFB;&#x7EDF;&#x901A;&#x5E38;&#x91C7;&#x7528;&#x677E;&#x5F1B;&#x5185;&#x5B58;&#x5E8F;&#x4EE5;&#x63D0;&#x9AD8;&#x6027;&#x80FD;&#xFF1A;</p>
<ol>
<li><p><strong>&#x5199;&#x7F13;&#x51B2;&#x4E0E;&#x5408;&#x5E76;</strong></p>
<ul>
<li>&#x5EF6;&#x8FDF;&#x5199;&#x5165;&#x51CF;&#x5C11;&#x5E26;&#x5BBD;&#x538B;&#x529B;</li>
<li>&#x76F8;&#x90BB;&#x5730;&#x5740;&#x5199;&#x5408;&#x5E76;</li>
<li>&#x5199;&#x5C4F;&#x969C;&#x5F3A;&#x5236;&#x5237;&#x65B0;</li>
</ul>
</li>
<li><p><strong>&#x4E71;&#x5E8F;&#x6267;&#x884C;</strong></p>
<ul>
<li>&#x8BFB;&#x5199;&#x91CD;&#x6392;&#x5E8F;&#x4F18;&#x5316;</li>
<li>&#x4F9D;&#x8D56;&#x8DDF;&#x8E2A;&#x4FDD;&#x8BC1;&#x6B63;&#x786E;&#x6027;</li>
<li>Memory fence&#x6307;&#x4EE4;</li>
</ul>
</li>
<li><p><strong>&#x9884;&#x53D6;&#x4E0E;&#x63A8;&#x6D4B;</strong></p>
<ul>
<li>&#x786C;&#x4EF6;&#x9884;&#x53D6;&#x51CF;&#x5C11;&#x5EF6;&#x8FDF;</li>
<li>&#x63A8;&#x6D4B;&#x6267;&#x884C;&#x9690;&#x85CF;&#x5EF6;&#x8FDF;</li>
<li>&#x9519;&#x8BEF;&#x6062;&#x590D;&#x673A;&#x5236;</li>
</ul>
</li>
</ol>
<h2 id="174-chiplet&#x4E0E;&#x591A;die&#x5C01;&#x88C5;">17.4 Chiplet&#x4E0E;&#x591A;die&#x5C01;&#x88C5;</h2>
<h3 id="1741-chiplet&#x6280;&#x672F;&#x6982;&#x8FF0;">17.4.1 Chiplet&#x6280;&#x672F;&#x6982;&#x8FF0;</h3>
<p>Chiplet&#x4EE3;&#x8868;&#x4E86;FPGA&#x6269;&#x5C55;&#x7684;&#x65B0;&#x8303;&#x5F0F;&#xFF0C;&#x901A;&#x8FC7;&#x5148;&#x8FDB;&#x5C01;&#x88C5;&#x6280;&#x672F;&#x5728;&#x5355;&#x4E2A;&#x5C01;&#x88C5;&#x5185;&#x96C6;&#x6210;&#x591A;&#x4E2A;&#x88F8;&#x7247;&#xFF1A;</p>
<p><strong>&#x6280;&#x672F;&#x4F18;&#x52BF;</strong></p>
<ul>
<li><strong>&#x826F;&#x7387;&#x63D0;&#x5347;</strong>&#xFF1A;&#x5C0F;die&#x826F;&#x7387;&#x8FDC;&#x9AD8;&#x4E8E;&#x5927;die</li>
<li><strong>&#x5F02;&#x6784;&#x96C6;&#x6210;</strong>&#xFF1A;&#x4E0D;&#x540C;&#x5DE5;&#x827A;&#x8282;&#x70B9;&#x6DF7;&#x5408;</li>
<li><strong>&#x6210;&#x672C;&#x4F18;&#x5316;</strong>&#xFF1A;&#x590D;&#x7528;&#x6210;&#x719F;IP</li>
<li><strong>&#x7075;&#x6D3B;&#x914D;&#x7F6E;</strong>&#xFF1A;&#x6A21;&#x5757;&#x5316;&#x8BBE;&#x8BA1;</li>
</ul>
<p><strong>&#x4E3B;&#x8981;&#x6311;&#x6218;</strong></p>
<ul>
<li>Die&#x95F4;&#x4E92;&#x8054;&#x5E26;&#x5BBD;&#x548C;&#x5EF6;&#x8FDF;</li>
<li>&#x529F;&#x8017;&#x548C;&#x6563;&#x70ED;&#x7BA1;&#x7406;</li>
<li>&#x6D4B;&#x8BD5;&#x548C;&#x826F;&#x7387;&#x7B5B;&#x9009;</li>
<li>EDA&#x5DE5;&#x5177;&#x94FE;&#x652F;&#x6301;</li>
</ul>
<h3 id="1742-die&#x95F4;&#x4E92;&#x8054;&#x6280;&#x672F;">17.4.2 Die&#x95F4;&#x4E92;&#x8054;&#x6280;&#x672F;</h3>
<p><strong>1. &#x7845;&#x4E2D;&#x4ECB;&#x5C42;&#xFF08;Silicon Interposer&#xFF09;</strong></p>
<pre><code>&#x7279;&#x6027;&#xFF1A;
- &#x4E92;&#x8054;&#x5BC6;&#x5EA6;&#xFF1A;10-50&#x3BC;m pitch
- &#x5E26;&#x5BBD;&#xFF1A;&gt;1TB/s per die
- &#x5EF6;&#x8FDF;&#xFF1A;&lt;5ns
- &#x529F;&#x8017;&#xFF1A;0.1-0.5pJ/bit
&#x5E94;&#x7528;&#xFF1A;Xilinx Virtex UltraScale+ HBM
</code></pre><p><strong>2. &#x6247;&#x51FA;&#x578B;&#x5C01;&#x88C5;&#xFF08;Fan-out&#xFF09;</strong></p>
<ul>
<li>RDL&#xFF08;&#x518D;&#x5E03;&#x7EBF;&#x5C42;&#xFF09;&#x5B9E;&#x73B0;&#x4E92;&#x8054;</li>
<li>&#x6210;&#x672C;&#x4F4E;&#x4E8E;&#x7845;&#x4E2D;&#x4ECB;&#x5C42;</li>
<li>&#x9002;&#x5408;&#x4E2D;&#x7B49;&#x5E26;&#x5BBD;&#x9700;&#x6C42;</li>
</ul>
<p><strong>3. &#x7845;&#x6865;&#xFF08;Silicon Bridge&#xFF09;</strong></p>
<ul>
<li>Intel EMIB&#x6280;&#x672F;</li>
<li>&#x5C40;&#x90E8;&#x9AD8;&#x5BC6;&#x5EA6;&#x4E92;&#x8054;</li>
<li>&#x964D;&#x4F4E;interposer&#x6210;&#x672C;</li>
</ul>
<p><strong>4. 3D&#x5806;&#x53E0;&#xFF08;Die Stacking&#xFF09;</strong></p>
<ul>
<li>TSV&#xFF08;&#x7845;&#x901A;&#x5B54;&#xFF09;&#x5782;&#x76F4;&#x4E92;&#x8054;</li>
<li>&#x6700;&#x77ED;&#x4E92;&#x8054;&#x8DEF;&#x5F84;</li>
<li>&#x6563;&#x70ED;&#x662F;&#x4E3B;&#x8981;&#x6311;&#x6218;</li>
</ul>
<h3 id="1743-chiplet&#x67B6;&#x6784;&#x8BBE;&#x8BA1;">17.4.3 Chiplet&#x67B6;&#x6784;&#x8BBE;&#x8BA1;</h3>
<p><strong>Xilinx Versal AI Edge&#x6848;&#x4F8B;&#x5206;&#x6790;</strong></p>
<pre><code>&#x67B6;&#x6784;&#x7EC4;&#x6210;&#xFF1A;
- AI&#x5F15;&#x64CE;&#x9635;&#x5217;&#xFF1A;400 TOPS INT8
- &#x53EF;&#x7F16;&#x7A0B;&#x903B;&#x8F91;&#xFF1A;100&#x4E07;LUT
- &#x5904;&#x7406;&#x5668;&#x5B50;&#x7CFB;&#x7EDF;&#xFF1A;ARM Cortex-A72
- &#x7F51;&#x7EDC;&#x5355;&#x5143;&#xFF1A;600G&#x4EE5;&#x592A;&#x7F51;
- &#x5B58;&#x50A8;&#x63A7;&#x5236;&#x5668;&#xFF1A;LPDDR4/5

&#x4E92;&#x8054;&#x67B6;&#x6784;&#xFF1A;
- NoC&#xFF08;&#x7247;&#x4E0A;&#x7F51;&#x7EDC;&#xFF09;&#xFF1A;1TB/s&#x5E26;&#x5BBD;
- AIE&#x9635;&#x5217;&#x4E92;&#x8054;&#xFF1A;&#x6BCF;tile 384GB/s
- PL-AIE&#x63A5;&#x53E3;&#xFF1A;512-bit AXI
</code></pre><p><strong>&#x8BBE;&#x8BA1;&#x8003;&#x8651;</strong></p>
<ol>
<li><p><strong>&#x529F;&#x80FD;&#x5212;&#x5206;</strong></p>
<ul>
<li>&#x8BA1;&#x7B97;&#x5BC6;&#x96C6;&#x2192;AI&#x5F15;&#x64CE;</li>
<li>&#x63A7;&#x5236;&#x903B;&#x8F91;&#x2192;ARM&#x5904;&#x7406;&#x5668;</li>
<li>&#x5B9A;&#x5236;&#x52A0;&#x901F;&#x2192;&#x53EF;&#x7F16;&#x7A0B;&#x903B;&#x8F91;</li>
<li>I/O&#x5904;&#x7406;&#x2192;&#x4E13;&#x7528;&#x786C;&#x6838;</li>
</ul>
</li>
<li><p><strong>&#x6570;&#x636E;&#x6D41;&#x4F18;&#x5316;</strong></p>
<ul>
<li>&#x6700;&#x5C0F;&#x5316;die&#x95F4;&#x6570;&#x636E;&#x4F20;&#x8F93;</li>
<li>&#x672C;&#x5730;&#x5316;&#x8BA1;&#x7B97;&#x548C;&#x5B58;&#x50A8;</li>
<li>&#x6D41;&#x6C34;&#x7EBF;&#x5E76;&#x884C;&#x5904;&#x7406;</li>
</ul>
</li>
<li><p><strong>&#x529F;&#x8017;&#x57DF;&#x7BA1;&#x7406;</strong></p>
<ul>
<li>&#x72EC;&#x7ACB;&#x7535;&#x6E90;&#x57DF;&#x63A7;&#x5236;</li>
<li>&#x52A8;&#x6001;&#x7535;&#x538B;&#x9891;&#x7387;&#x8C03;&#x8282;</li>
<li>&#x7EC6;&#x7C92;&#x5EA6;&#x65F6;&#x949F;&#x95E8;&#x63A7;</li>
</ul>
</li>
</ol>
<h3 id="1744-&#x591A;die-fpga&#x7F16;&#x7A0B;&#x6A21;&#x578B;">17.4.4 &#x591A;die FPGA&#x7F16;&#x7A0B;&#x6A21;&#x578B;</h3>
<p><strong>&#x7EDF;&#x4E00;&#x5730;&#x5740;&#x7A7A;&#x95F4;</strong></p>
<pre><code class="lang-systemverilog">// &#x8DE8;die&#x5730;&#x5740;&#x6620;&#x5C04;
localparam DIE0_BASE = 48&apos;h0000_0000_0000;
localparam DIE1_BASE = 48&apos;h1000_0000_0000;
localparam DIE2_BASE = 48&apos;h2000_0000_0000;

// &#x81EA;&#x52A8;&#x8DEF;&#x7531;&#x5230;&#x76EE;&#x6807;die
always_comb begin
    case (addr[47:44])
        4&apos;h0: target_die = 2&apos;b00;
        4&apos;h1: target_die = 2&apos;b01;
        4&apos;h2: target_die = 2&apos;b10;
        default: target_die = 2&apos;b11;
    endcase
end
</code></pre>
<p><strong>&#x5206;&#x533A;&#x7F16;&#x8BD1;&#x6D41;&#x7A0B;</strong></p>
<ol>
<li>&#x903B;&#x8F91;&#x5206;&#x533A;&#xFF1A;&#x5C06;&#x8BBE;&#x8BA1;&#x6620;&#x5C04;&#x5230;&#x4E0D;&#x540C;die</li>
<li>&#x7269;&#x7406;&#x4F18;&#x5316;&#xFF1A;&#x8003;&#x8651;die&#x95F4;&#x5EF6;&#x8FDF;</li>
<li>&#x65F6;&#x5E8F;&#x5206;&#x6790;&#xFF1A;&#x8DE8;die&#x8DEF;&#x5F84;&#x7279;&#x6B8A;&#x5904;&#x7406;</li>
<li>&#x5E03;&#x5C40;&#x5E03;&#x7EBF;&#xFF1A;die&#x7EA7;&#x5E76;&#x884C;&#x5904;&#x7406;</li>
</ol>
<h3 id="1745-&#x672A;&#x6765;&#x53D1;&#x5C55;&#x8D8B;&#x52BF;">17.4.5 &#x672A;&#x6765;&#x53D1;&#x5C55;&#x8D8B;&#x52BF;</h3>
<p><strong>UCIe&#x6807;&#x51C6;&#xFF08;Universal Chiplet Interconnect Express&#xFF09;</strong></p>
<ul>
<li>&#x6807;&#x51C6;&#x5316;die&#x95F4;&#x63A5;&#x53E3;</li>
<li>&#x652F;&#x6301;&#x591A;&#x4F9B;&#x5E94;&#x5546;&#x96C6;&#x6210;</li>
<li>&#x534F;&#x8BAE;&#x6808;&#xFF1A;&#x7269;&#x7406;&#x5C42;&#x5230;&#x4F20;&#x8F93;&#x5C42;</li>
</ul>
<p><strong>&#x5148;&#x8FDB;&#x5C01;&#x88C5;&#x8DEF;&#x7EBF;&#x56FE;</strong></p>
<pre><code>2024: 2.5D&#x4E3B;&#x6D41;&#xFF0C;10&#x3BC;m pitch
2026: 3D&#x96C6;&#x6210;&#xFF0C;5&#x3BC;m pitch
2028: &#x6676;&#x5706;&#x7EA7;&#x96C6;&#x6210;&#xFF0C;&lt;2&#x3BC;m pitch
2030: &#x5149;&#x7535;&#x6DF7;&#x5408;&#x96C6;&#x6210;
</code></pre><h2 id="175-&#x6269;&#x5C55;&#x6027;&#x80FD;&#x5EFA;&#x6A21;">17.5 &#x6269;&#x5C55;&#x6027;&#x80FD;&#x5EFA;&#x6A21;</h2>
<p>&#x591A;FPGA&#x7CFB;&#x7EDF;&#x7684;&#x6027;&#x80FD;&#x5EFA;&#x6A21;&#x662F;&#x8BBE;&#x8BA1;&#x5927;&#x89C4;&#x6A21;&#x7CFB;&#x7EDF;&#x7684;&#x5173;&#x952E;&#x3002;&#x672C;&#x8282;&#x4ECB;&#x7ECD;&#x5982;&#x4F55;&#x5EFA;&#x7ACB;&#x51C6;&#x786E;&#x7684;&#x6027;&#x80FD;&#x6A21;&#x578B;&#xFF0C;&#x9884;&#x6D4B;&#x7CFB;&#x7EDF;&#x6269;&#x5C55;&#x6027;&#xFF0C;&#x5E76;&#x4F18;&#x5316;&#x7CFB;&#x7EDF;&#x67B6;&#x6784;&#x3002;</p>
<h3 id="1751-&#x6027;&#x80FD;&#x5EFA;&#x6A21;&#x57FA;&#x7840;">17.5.1 &#x6027;&#x80FD;&#x5EFA;&#x6A21;&#x57FA;&#x7840;</h3>
<p><strong>1. Roofline&#x6A21;&#x578B;</strong></p>
<pre><code class="lang-python"><span class="hljs-comment"># &#x591A;FPGA&#x7CFB;&#x7EDF;Roofline&#x6A21;&#x578B;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiPGAooflineModel</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, num_fpgas, fpga_spec)</span>:</span>
        self.num_fpgas = num_fpgas
        self.peak_compute = fpga_spec[<span class="hljs-string">&apos;peak_gflops&apos;</span>] * num_fpgas
        self.peak_memory_bw = fpga_spec[<span class="hljs-string">&apos;memory_bw_gb/s&apos;</span>] * num_fpgas
        self.interconnect_bw = fpga_spec[<span class="hljs-string">&apos;interconnect_bw_gb/s&apos;</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_performance</span><span class="hljs-params">(self, arithmetic_intensity)</span>:</span>
        <span class="hljs-comment"># &#x8003;&#x8651;&#x4E92;&#x8054;&#x5E26;&#x5BBD;&#x9650;&#x5236;</span>
        memory_bound = arithmetic_intensity * self.peak_memory_bw
        compute_bound = self.peak_compute
        interconnect_bound = arithmetic_intensity * self.interconnect_bw * self.num_fpgas

        <span class="hljs-keyword">return</span> min(memory_bound, compute_bound, interconnect_bound)
</code></pre>
<p><strong>2. Amdahl&#x5B9A;&#x5F8B;&#x6269;&#x5C55;</strong></p>
<pre><code class="lang-systemverilog">// &#x591A;FPGA&#x5E76;&#x884C;&#x6548;&#x7387;&#x8BA1;&#x7B97;
module parallel_efficiency_calculator #(
    parameter MAX_FPGAS = 64
) (
    input  logic [31:0] serial_fraction,    // &#x4E32;&#x884C;&#x90E8;&#x5206;&#x6BD4;&#x4F8B; (&#x5B9A;&#x70B9;&#x5C0F;&#x6570;)
    input  logic [31:0] communication_cost, // &#x901A;&#x4FE1;&#x5F00;&#x9500;
    input  logic [7:0]  num_fpgas,
    output logic [31:0] speedup,
    output logic [31:0] efficiency
);

    logic [63:0] parallel_fraction;
    logic [63:0] ideal_speedup;
    logic [63:0] actual_speedup;

    always_comb begin
        // &#x8BA1;&#x7B97;&#x5E76;&#x884C;&#x90E8;&#x5206;
        parallel_fraction = 32&apos;h10000 - serial_fraction; // 1.0 - serial

        // &#x7406;&#x60F3;&#x52A0;&#x901F;&#x6BD4;
        ideal_speedup = (32&apos;h10000 * num_fpgas) / 
                       (serial_fraction + parallel_fraction);

        // &#x8003;&#x8651;&#x901A;&#x4FE1;&#x5F00;&#x9500;&#x7684;&#x5B9E;&#x9645;&#x52A0;&#x901F;&#x6BD4;
        actual_speedup = ideal_speedup / 
                        (32&apos;h10000 + communication_cost * (num_fpgas - 1));

        speedup = actual_speedup[31:0];
        efficiency = (actual_speedup * 32&apos;h10000) / (num_fpgas &lt;&lt; 16);
    end
endmodule
</code></pre>
<h3 id="1752-&#x901A;&#x4FE1;&#x6A21;&#x578B;">17.5.2 &#x901A;&#x4FE1;&#x6A21;&#x578B;</h3>
<p><strong>1. &#x5EF6;&#x8FDF;-&#x5E26;&#x5BBD;&#x6A21;&#x578B;</strong></p>
<pre><code class="lang-systemverilog">// &#x591A;FPGA&#x901A;&#x4FE1;&#x6027;&#x80FD;&#x6A21;&#x578B;
module communication_model #(
    parameter DATA_WIDTH = 512,
    parameter NUM_FPGAS = 8
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x901A;&#x4FE1;&#x53C2;&#x6570;
    input  logic [31:0] message_size,      // &#x5B57;&#x8282;
    input  logic [31:0] hop_latency_ns,    // &#x6BCF;&#x8DF3;&#x5EF6;&#x8FDF;
    input  logic [31:0] link_bandwidth_gbps,
    input  logic [7:0]  src_fpga,
    input  logic [7:0]  dst_fpga,

    // &#x6027;&#x80FD;&#x9884;&#x6D4B;
    output logic [31:0] transfer_latency_ns,
    output logic [31:0] effective_bandwidth_mbps
);

    // &#x62D3;&#x6251;&#x76F8;&#x5173;&#x8BA1;&#x7B97;
    logic [7:0] hop_count;
    logic [31:0] serialization_delay;
    logic [31:0] propagation_delay;

    // &#x8BA1;&#x7B97;&#x8DF3;&#x6570;&#xFF08;&#x5047;&#x8BBE;mesh&#x62D3;&#x6251;&#xFF09;
    always_comb begin
        logic [7:0] x_dist, y_dist;
        logic [3:0] src_x, src_y, dst_x, dst_y;

        // 2D mesh&#x5750;&#x6807;
        src_x = src_fpga[3:0];
        src_y = src_fpga[7:4];
        dst_x = dst_fpga[3:0];
        dst_y = dst_fpga[7:4];

        x_dist = (src_x &gt; dst_x) ? (src_x - dst_x) : (dst_x - src_x);
        y_dist = (src_y &gt; dst_y) ? (src_y - dst_y) : (dst_y - src_y);

        hop_count = x_dist + y_dist;
    end

    // &#x5EF6;&#x8FDF;&#x8BA1;&#x7B97;
    always_comb begin
        // &#x4F20;&#x64AD;&#x5EF6;&#x8FDF; = &#x8DF3;&#x6570; &#xD7; &#x6BCF;&#x8DF3;&#x5EF6;&#x8FDF;
        propagation_delay = hop_count * hop_latency_ns;

        // &#x5E8F;&#x5217;&#x5316;&#x5EF6;&#x8FDF; = &#x6D88;&#x606F;&#x5927;&#x5C0F; / &#x5E26;&#x5BBD;
        serialization_delay = (message_size * 8 * 1000) / link_bandwidth_gbps;

        // &#x603B;&#x5EF6;&#x8FDF;
        transfer_latency_ns = propagation_delay + serialization_delay;

        // &#x6709;&#x6548;&#x5E26;&#x5BBD;
        if (transfer_latency_ns &gt; 0)
            effective_bandwidth_mbps = (message_size * 8 * 1000000) / transfer_latency_ns;
        else
            effective_bandwidth_mbps = 0;
    end
endmodule
</code></pre>
<p><strong>2. &#x96C6;&#x5408;&#x901A;&#x4FE1;&#x6A21;&#x578B;</strong></p>
<pre><code class="lang-systemverilog">// &#x96C6;&#x5408;&#x901A;&#x4FE1;&#x64CD;&#x4F5C;&#x5EFA;&#x6A21;
module collective_comm_model #(
    parameter NUM_FPGAS = 16,
    parameter DATA_SIZE = 1024  // KB
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x64CD;&#x4F5C;&#x7C7B;&#x578B;
    input  logic [2:0]  operation,  // 0:broadcast, 1:reduce, 2:allreduce, 3:allgather
    input  logic [31:0] link_bw_gbps,
    input  logic [31:0] link_latency_ns,

    // &#x6027;&#x80FD;&#x8F93;&#x51FA;
    output logic [31:0] total_time_us,
    output logic [31:0] algorithm_steps
);

    // &#x7B97;&#x6CD5;&#x6B65;&#x9AA4;&#x8BA1;&#x7B97;
    always_comb begin
        case (operation)
            3&apos;b000: begin // Broadcast (&#x4E8C;&#x53C9;&#x6811;)
                algorithm_steps = $clog2(NUM_FPGAS);
                total_time_us = algorithm_steps * 
                               ((DATA_SIZE * 8) / link_bw_gbps + link_latency_ns / 1000);
            end

            3&apos;b001: begin // Reduce (&#x4E8C;&#x53C9;&#x6811;)
                algorithm_steps = $clog2(NUM_FPGAS);
                total_time_us = algorithm_steps * 
                               ((DATA_SIZE * 8) / link_bw_gbps + link_latency_ns / 1000);
            end

            3&apos;b010: begin // Allreduce (ring&#x7B97;&#x6CD5;)
                algorithm_steps = 2 * (NUM_FPGAS - 1);
                total_time_us = algorithm_steps * 
                               ((DATA_SIZE * 8 / NUM_FPGAS) / link_bw_gbps + 
                                link_latency_ns / 1000);
            end

            3&apos;b011: begin // Allgather (ring&#x7B97;&#x6CD5;)
                algorithm_steps = NUM_FPGAS - 1;
                total_time_us = algorithm_steps * 
                               ((DATA_SIZE * 8) / link_bw_gbps + link_latency_ns / 1000);
            end

            default: begin
                algorithm_steps = 0;
                total_time_us = 0;
            end
        endcase
    end
endmodule
</code></pre>
<h3 id="1753-&#x8D1F;&#x8F7D;&#x5E73;&#x8861;&#x6A21;&#x578B;">17.5.3 &#x8D1F;&#x8F7D;&#x5E73;&#x8861;&#x6A21;&#x578B;</h3>
<p><strong>1. &#x52A8;&#x6001;&#x8D1F;&#x8F7D;&#x6A21;&#x578B;</strong></p>
<pre><code class="lang-systemverilog">// &#x8D1F;&#x8F7D;&#x5E73;&#x8861;&#x6027;&#x80FD;&#x9884;&#x6D4B;
module load_balance_model #(
    parameter NUM_FPGAS = 8,
    parameter NUM_TASKS = 1024
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x4EFB;&#x52A1;&#x7279;&#x5F81;
    input  logic [31:0] task_compute_time [NUM_TASKS],
    input  logic [31:0] task_data_size [NUM_TASKS],
    input  logic [2:0]  scheduling_policy,  // 0:static, 1:dynamic, 2:work-stealing

    // &#x6027;&#x80FD;&#x9884;&#x6D4B;
    output logic [31:0] makespan,           // &#x603B;&#x5B8C;&#x6210;&#x65F6;&#x95F4;
    output logic [31:0] load_imbalance,     // &#x8D1F;&#x8F7D;&#x4E0D;&#x5E73;&#x8861;&#x5EA6;
    output logic [31:0] fpga_utilization [NUM_FPGAS]
);

    // &#x6BCF;&#x4E2A;FPGA&#x7684;&#x8D1F;&#x8F7D;
    logic [31:0] fpga_load [NUM_FPGAS];
    logic [31:0] fpga_task_count [NUM_FPGAS];
    logic [31:0] max_load, min_load, avg_load;

    // &#x9759;&#x6001;&#x8C03;&#x5EA6;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            for (int i = 0; i &lt; NUM_FPGAS; i++) begin
                fpga_load[i] &lt;= 0;
                fpga_task_count[i] &lt;= 0;
            end
        end else if (scheduling_policy == 3&apos;b000) begin
            // &#x8F6E;&#x8BE2;&#x5206;&#x914D;
            for (int i = 0; i &lt; NUM_TASKS; i++) begin
                int fpga_id = i % NUM_FPGAS;
                fpga_load[fpga_id] &lt;= fpga_load[fpga_id] + task_compute_time[i];
                fpga_task_count[fpga_id] &lt;= fpga_task_count[fpga_id] + 1;
            end
        end else if (scheduling_policy == 3&apos;b001) begin
            // &#x52A8;&#x6001;&#x6700;&#x5C0F;&#x8D1F;&#x8F7D;&#x4F18;&#x5148;
            for (int i = 0; i &lt; NUM_TASKS; i++) begin
                // &#x627E;&#x5230;&#x8D1F;&#x8F7D;&#x6700;&#x5C0F;&#x7684;FPGA
                automatic int min_fpga = 0;
                automatic logic [31:0] min_current_load = fpga_load[0];

                for (int j = 1; j &lt; NUM_FPGAS; j++) begin
                    if (fpga_load[j] &lt; min_current_load) begin
                        min_current_load = fpga_load[j];
                        min_fpga = j;
                    end
                end

                fpga_load[min_fpga] &lt;= fpga_load[min_fpga] + task_compute_time[i];
                fpga_task_count[min_fpga] &lt;= fpga_task_count[min_fpga] + 1;
            end
        end
    end

    // &#x6027;&#x80FD;&#x6307;&#x6807;&#x8BA1;&#x7B97;
    always_comb begin
        max_load = fpga_load[0];
        min_load = fpga_load[0];
        avg_load = 0;

        for (int i = 0; i &lt; NUM_FPGAS; i++) begin
            if (fpga_load[i] &gt; max_load) max_load = fpga_load[i];
            if (fpga_load[i] &lt; min_load) min_load = fpga_load[i];
            avg_load = avg_load + fpga_load[i];
        end

        avg_load = avg_load / NUM_FPGAS;
        makespan = max_load;
        load_imbalance = ((max_load - min_load) * 100) / avg_load;

        // &#x8BA1;&#x7B97;&#x5229;&#x7528;&#x7387;
        for (int i = 0; i &lt; NUM_FPGAS; i++) begin
            fpga_utilization[i] = (fpga_load[i] * 100) / makespan;
        end
    end
endmodule
</code></pre>
<h3 id="1754-&#x6269;&#x5C55;&#x6027;&#x5206;&#x6790;">17.5.4 &#x6269;&#x5C55;&#x6027;&#x5206;&#x6790;</h3>
<p><strong>1. &#x5F3A;&#x6269;&#x5C55;&#x6027;&#x6A21;&#x578B;</strong></p>
<pre><code class="lang-systemverilog">// &#x5F3A;&#x6269;&#x5C55;&#x6027;(Strong Scaling)&#x5206;&#x6790;
module strong_scaling_analyzer #(
    parameter MAX_FPGAS = 64,
    parameter PROBLEM_SIZE = 32&apos;h1000000  // &#x56FA;&#x5B9A;&#x95EE;&#x9898;&#x89C4;&#x6A21;
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x5E94;&#x7528;&#x7279;&#x5F81;
    input  logic [31:0] computation_ops,    // &#x603B;&#x8BA1;&#x7B97;&#x64CD;&#x4F5C;&#x6570;
    input  logic [31:0] communication_bytes,// &#x901A;&#x4FE1;&#x6570;&#x636E;&#x91CF;
    input  logic [31:0] serial_fraction,    // &#x4E32;&#x884C;&#x90E8;&#x5206;&#x6BD4;&#x4F8B;

    // FPGA&#x89C4;&#x683C;
    input  logic [31:0] fpga_gflops,
    input  logic [31:0] interconnect_gbps,

    // &#x6269;&#x5C55;&#x6027;&#x5206;&#x6790;&#x7ED3;&#x679C;
    output logic [31:0] ideal_speedup [MAX_FPGAS],
    output logic [31:0] actual_speedup [MAX_FPGAS],
    output logic [31:0] parallel_efficiency [MAX_FPGAS],
    output logic [7:0]  optimal_fpga_count
);

    // &#x8BA1;&#x7B97;&#x6BCF;&#x79CD;FPGA&#x6570;&#x91CF;&#x4E0B;&#x7684;&#x6027;&#x80FD;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            optimal_fpga_count &lt;= 1;
        end else begin
            logic [31:0] best_speedup = 0;

            for (int n = 1; n &lt;= MAX_FPGAS; n++) begin
                // &#x7406;&#x60F3;&#x52A0;&#x901F;&#x6BD4;&#xFF08;Amdahl&#x5B9A;&#x5F8B;&#xFF09;
                ideal_speedup[n-1] = (32&apos;h10000 * n) / 
                                    (serial_fraction + (32&apos;h10000 - serial_fraction));

                // &#x8BA1;&#x7B97;&#x65F6;&#x95F4;
                logic [63:0] compute_time = computation_ops / (fpga_gflops * n);

                // &#x901A;&#x4FE1;&#x65F6;&#x95F4;&#xFF08;&#x5047;&#x8BBE;all-to-all&#xFF09;
                logic [63:0] comm_time = (communication_bytes * (n-1)) / 
                                        (interconnect_gbps * 125); // Gbps to MB/s

                // &#x5B9E;&#x9645;&#x6267;&#x884C;&#x65F6;&#x95F4;
                logic [63:0] total_time = compute_time + comm_time;
                logic [63:0] single_fpga_time = computation_ops / fpga_gflops;

                // &#x5B9E;&#x9645;&#x52A0;&#x901F;&#x6BD4;
                actual_speedup[n-1] = single_fpga_time / total_time;

                // &#x5E76;&#x884C;&#x6548;&#x7387;
                parallel_efficiency[n-1] = (actual_speedup[n-1] * 100) / n;

                // &#x8BB0;&#x5F55;&#x6700;&#x4F73;&#x914D;&#x7F6E;
                if (actual_speedup[n-1] &gt; best_speedup) begin
                    best_speedup = actual_speedup[n-1];
                    optimal_fpga_count = n;
                end
            end
        end
    end
endmodule
</code></pre>
<p><strong>2. &#x5F31;&#x6269;&#x5C55;&#x6027;&#x6A21;&#x578B;</strong></p>
<pre><code class="lang-systemverilog">// &#x5F31;&#x6269;&#x5C55;&#x6027;(Weak Scaling)&#x5206;&#x6790;
module weak_scaling_analyzer #(
    parameter MAX_FPGAS = 64,
    parameter BASE_PROBLEM_SIZE = 32&apos;h100000
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x95EE;&#x9898;&#x89C4;&#x6A21;&#x968F;FPGA&#x6570;&#x91CF;&#x7EBF;&#x6027;&#x589E;&#x957F;
    input  logic [31:0] ops_per_fpga,      // &#x6BCF;&#x4E2A;FPGA&#x7684;&#x8BA1;&#x7B97;&#x91CF;
    input  logic [31:0] data_per_fpga,     // &#x6BCF;&#x4E2A;FPGA&#x7684;&#x6570;&#x636E;&#x91CF;
    input  logic [31:0] ghost_zone_size,   // &#x8FB9;&#x754C;&#x4EA4;&#x6362;&#x6570;&#x636E;&#x91CF;

    // &#x6027;&#x80FD;&#x9884;&#x6D4B;
    output logic [31:0] execution_time [MAX_FPGAS],
    output logic [31:0] weak_efficiency [MAX_FPGAS],
    output logic [31:0] communication_overhead [MAX_FPGAS]
);

    always_comb begin
        for (int n = 1; n &lt;= MAX_FPGAS; n++) begin
            // &#x8BA1;&#x7B97;&#x65F6;&#x95F4;&#xFF08;&#x6BCF;&#x4E2A;FPGA&#x8D1F;&#x8F7D;&#x56FA;&#x5B9A;&#xFF09;
            logic [31:0] compute_time = ops_per_fpga;

            // &#x901A;&#x4FE1;&#x91CF;&#x968F;&#x90BB;&#x5C45;&#x6570;&#x91CF;&#x589E;&#x957F;
            logic [31:0] neighbors;
            if (n == 1) neighbors = 0;
            else if (n &lt;= 4) neighbors = n - 1;
            else if (n &lt;= 16) neighbors = 4;  // 2D mesh
            else neighbors = 6;  // 3D mesh

            logic [31:0] comm_volume = ghost_zone_size * neighbors;
            logic [31:0] comm_time = comm_volume / 1000;  // &#x7B80;&#x5316;&#x6A21;&#x578B;

            // &#x603B;&#x6267;&#x884C;&#x65F6;&#x95F4;
            execution_time[n-1] = compute_time + comm_time;

            // &#x5F31;&#x6269;&#x5C55;&#x6548;&#x7387;
            weak_efficiency[n-1] = (compute_time * 100) / execution_time[n-1];

            // &#x901A;&#x4FE1;&#x5F00;&#x9500;&#x6BD4;&#x4F8B;
            communication_overhead[n-1] = (comm_time * 100) / execution_time[n-1];
        end
    end
endmodule
</code></pre>
<h3 id="1755-&#x6027;&#x80FD;&#x4F18;&#x5316;&#x7B56;&#x7565;">17.5.5 &#x6027;&#x80FD;&#x4F18;&#x5316;&#x7B56;&#x7565;</h3>
<p><strong>1. &#x901A;&#x4FE1;&#x4F18;&#x5316;&#x6A21;&#x578B;</strong></p>
<pre><code class="lang-systemverilog">// &#x901A;&#x4FE1;&#x6A21;&#x5F0F;&#x4F18;&#x5316;&#x5206;&#x6790;
module comm_optimization_model (
    input  logic        clk,
    input  logic        rst_n,

    // &#x901A;&#x4FE1;&#x6A21;&#x5F0F;&#x53C2;&#x6570;
    input  logic [31:0] message_size,
    input  logic [7:0]  num_fpgas,
    input  logic [2:0]  comm_pattern,  // 0:nearest, 1:all-to-all, 2:hierarchical

    // &#x4F18;&#x5316;&#x6280;&#x672F;
    input  logic        message_aggregation,
    input  logic        overlap_comp_comm,
    input  logic [7:0]  pipeline_depth,

    // &#x6027;&#x80FD;&#x5F71;&#x54CD;
    output logic [31:0] baseline_time,
    output logic [31:0] optimized_time,
    output logic [31:0] improvement_percent
);

    always_comb begin
        // &#x57FA;&#x51C6;&#x901A;&#x4FE1;&#x65F6;&#x95F4;
        case (comm_pattern)
            3&apos;b000: baseline_time = message_size * 4;        // &#x6700;&#x8FD1;&#x90BB;
            3&apos;b001: baseline_time = message_size * num_fpgas; // &#x5168;&#x4E92;&#x8054;
            3&apos;b010: baseline_time = message_size * $clog2(num_fpgas); // &#x5C42;&#x6B21;&#x5316;
            default: baseline_time = message_size * num_fpgas;
        endcase

        // &#x5E94;&#x7528;&#x4F18;&#x5316;
        optimized_time = baseline_time;

        if (message_aggregation) begin
            // &#x6D88;&#x606F;&#x805A;&#x5408;&#x51CF;&#x5C11;&#x5EF6;&#x8FDF;&#x5F00;&#x9500;
            optimized_time = optimized_time * 3 / 4;
        end

        if (overlap_comp_comm) begin
            // &#x8BA1;&#x7B97;&#x901A;&#x4FE1;&#x91CD;&#x53E0;
            optimized_time = optimized_time / 2;
        end

        if (pipeline_depth &gt; 1) begin
            // &#x6D41;&#x6C34;&#x7EBF;&#x5E76;&#x884C;
            optimized_time = optimized_time / pipeline_depth;
        end

        // &#x6539;&#x8FDB;&#x767E;&#x5206;&#x6BD4;
        improvement_percent = ((baseline_time - optimized_time) * 100) / baseline_time;
    end
endmodule
</code></pre>
<p><strong>2. &#x62D3;&#x6251;&#x611F;&#x77E5;&#x4F18;&#x5316;</strong></p>
<pre><code class="lang-systemverilog">// &#x62D3;&#x6251;&#x611F;&#x77E5;&#x4EFB;&#x52A1;&#x6620;&#x5C04;
module topology_aware_mapping #(
    parameter NUM_FPGAS = 16,
    parameter NUM_TASKS = 64
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x4EFB;&#x52A1;&#x901A;&#x4FE1;&#x56FE;
    input  logic [31:0] comm_matrix [NUM_TASKS][NUM_TASKS],

    // &#x7269;&#x7406;&#x62D3;&#x6251;&#xFF08;&#x90BB;&#x63A5;&#x77E9;&#x9635;&#xFF09;
    input  logic [7:0]  topology_distance [NUM_FPGAS][NUM_FPGAS],

    // &#x6620;&#x5C04;&#x7ED3;&#x679C;
    output logic [7:0]  task_to_fpga [NUM_TASKS],
    output logic [31:0] total_comm_cost
);

    // &#x7B80;&#x5316;&#x7684;&#x6620;&#x5C04;&#x7B97;&#x6CD5;&#xFF08;&#x8D2A;&#x5FC3;&#xFF09;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            for (int i = 0; i &lt; NUM_TASKS; i++)
                task_to_fpga[i] &lt;= i % NUM_FPGAS;
        end else begin
            // &#x8BA1;&#x7B97;&#x5F53;&#x524D;&#x6620;&#x5C04;&#x7684;&#x901A;&#x4FE1;&#x4EE3;&#x4EF7;
            logic [31:0] current_cost = 0;

            for (int i = 0; i &lt; NUM_TASKS; i++) begin
                for (int j = i+1; j &lt; NUM_TASKS; j++) begin
                    if (comm_matrix[i][j] &gt; 0) begin
                        logic [7:0] fpga_i = task_to_fpga[i];
                        logic [7:0] fpga_j = task_to_fpga[j];
                        current_cost += comm_matrix[i][j] * 
                                      topology_distance[fpga_i][fpga_j];
                    end
                end
            end

            total_comm_cost &lt;= current_cost;

            // &#x5C1D;&#x8BD5;&#x6539;&#x8FDB;&#x6620;&#x5C04;&#xFF08;&#x7B80;&#x5316;&#x7248;&#x672C;&#xFF09;
            // &#x5B9E;&#x9645;&#x5B9E;&#x73B0;&#x9700;&#x8981;&#x66F4;&#x590D;&#x6742;&#x7684;&#x4F18;&#x5316;&#x7B97;&#x6CD5;
        end
    end
endmodule
</code></pre>
<h3 id="1756-&#x6027;&#x80FD;&#x9A8C;&#x8BC1;&#x6846;&#x67B6;">17.5.6 &#x6027;&#x80FD;&#x9A8C;&#x8BC1;&#x6846;&#x67B6;</h3>
<p><strong>1. &#x6027;&#x80FD;&#x8BA1;&#x6570;&#x5668;&#x96C6;&#x6210;</strong></p>
<pre><code class="lang-systemverilog">// &#x591A;FPGA&#x6027;&#x80FD;&#x76D1;&#x63A7;
module multi_fpga_perf_monitor #(
    parameter NUM_FPGAS = 8,
    parameter NUM_COUNTERS = 16
) (
    input  logic        clk,
    input  logic        rst_n,

    // &#x6765;&#x81EA;&#x5404;FPGA&#x7684;&#x6027;&#x80FD;&#x6570;&#x636E;
    input  logic [63:0] perf_counters [NUM_FPGAS][NUM_COUNTERS],
    input  logic        counter_valid [NUM_FPGAS],

    // &#x805A;&#x5408;&#x6027;&#x80FD;&#x6307;&#x6807;
    output logic [63:0] total_operations,
    output logic [63:0] total_cycles,
    output logic [31:0] system_efficiency,
    output logic [31:0] load_balance_factor
);

    // &#x805A;&#x5408;&#x8BA1;&#x7B97;
    always_ff @(posedge clk) begin
        if (!rst_n) begin
            total_operations &lt;= 0;
            total_cycles &lt;= 0;
        end else begin
            logic [63:0] sum_ops = 0;
            logic [63:0] max_cycles = 0;
            logic [63:0] min_ops = 64&apos;hFFFFFFFFFFFFFFFF;
            logic [63:0] max_ops = 0;

            for (int i = 0; i &lt; NUM_FPGAS; i++) begin
                if (counter_valid[i]) begin
                    // &#x5047;&#x8BBE;counter[0]&#x662F;&#x64CD;&#x4F5C;&#x6570;&#xFF0C;counter[1]&#x662F;&#x5468;&#x671F;&#x6570;
                    sum_ops += perf_counters[i][0];

                    if (perf_counters[i][1] &gt; max_cycles)
                        max_cycles = perf_counters[i][1];

                    if (perf_counters[i][0] &lt; min_ops)
                        min_ops = perf_counters[i][0];

                    if (perf_counters[i][0] &gt; max_ops)
                        max_ops = perf_counters[i][0];
                end
            end

            total_operations &lt;= sum_ops;
            total_cycles &lt;= max_cycles;

            // &#x7CFB;&#x7EDF;&#x6548;&#x7387; = &#x5B9E;&#x9645;&#x6027;&#x80FD; / &#x7406;&#x8BBA;&#x5CF0;&#x503C;&#x6027;&#x80FD;
            if (max_cycles &gt; 0)
                system_efficiency &lt;= (sum_ops * 100) / (NUM_FPGAS * max_cycles);

            // &#x8D1F;&#x8F7D;&#x5E73;&#x8861;&#x56E0;&#x5B50; = &#x6700;&#x5C0F;&#x8D1F;&#x8F7D; / &#x6700;&#x5927;&#x8D1F;&#x8F7D;
            if (max_ops &gt; 0)
                load_balance_factor &lt;= (min_ops * 100) / max_ops;
        end
    end
endmodule
</code></pre>
<p><strong>2. &#x6A21;&#x578B;&#x9A8C;&#x8BC1;&#x6BD4;&#x8F83;</strong></p>
<pre><code class="lang-systemverilog">// &#x6A21;&#x578B;&#x9884;&#x6D4B;&#x4E0E;&#x5B9E;&#x6D4B;&#x6BD4;&#x8F83;
module model_validation (
    input  logic        clk,
    input  logic        rst_n,

    // &#x6A21;&#x578B;&#x9884;&#x6D4B;
    input  logic [31:0] predicted_latency,
    input  logic [31:0] predicted_throughput,

    // &#x5B9E;&#x9645;&#x6D4B;&#x91CF;
    input  logic [31:0] measured_latency,
    input  logic [31:0] measured_throughput,
    input  logic        measurement_valid,

    // &#x9A8C;&#x8BC1;&#x7ED3;&#x679C;
    output logic [31:0] latency_error_percent,
    output logic [31:0] throughput_error_percent,
    output logic        model_accurate  // &#x8BEF;&#x5DEE;&lt;10%
);

    always_ff @(posedge clk) begin
        if (!rst_n) begin
            latency_error_percent &lt;= 0;
            throughput_error_percent &lt;= 0;
            model_accurate &lt;= 0;
        end else if (measurement_valid) begin
            // &#x8BA1;&#x7B97;&#x9884;&#x6D4B;&#x8BEF;&#x5DEE;
            logic [31:0] lat_diff, tput_diff;

            lat_diff = (predicted_latency &gt; measured_latency) ? 
                      (predicted_latency - measured_latency) :
                      (measured_latency - predicted_latency);

            tput_diff = (predicted_throughput &gt; measured_throughput) ?
                       (predicted_throughput - measured_throughput) :
                       (measured_throughput - predicted_throughput);

            // &#x8BEF;&#x5DEE;&#x767E;&#x5206;&#x6BD4;
            if (measured_latency &gt; 0)
                latency_error_percent &lt;= (lat_diff * 100) / measured_latency;

            if (measured_throughput &gt; 0)
                throughput_error_percent &lt;= (tput_diff * 100) / measured_throughput;

            // &#x5224;&#x65AD;&#x6A21;&#x578B;&#x51C6;&#x786E;&#x6027;
            model_accurate &lt;= (latency_error_percent &lt; 10) &amp;&amp; 
                            (throughput_error_percent &lt; 10);
        end
    end
endmodule
</code></pre>
<h2 id="&#x672C;&#x7AE0;&#x5C0F;&#x7ED3;">&#x672C;&#x7AE0;&#x5C0F;&#x7ED3;</h2>
<p>&#x672C;&#x7AE0;&#x6DF1;&#x5165;&#x63A2;&#x8BA8;&#x4E86;&#x591A;FPGA&#x7CFB;&#x7EDF;&#x8BBE;&#x8BA1;&#x7684;&#x5404;&#x4E2A;&#x65B9;&#x9762;&#xFF1A;</p>
<ol>
<li><strong>&#x9AD8;&#x901F;&#x4E92;&#x8054;&#x67B6;&#x6784;</strong>&#xFF1A;&#x4ECB;&#x7ECD;&#x4E86;&#x5404;&#x79CD;&#x4E92;&#x8054;&#x62D3;&#x6251;&#x3001;&#x4E32;&#x884C;&#x94FE;&#x8DEF;&#x6280;&#x672F;&#x548C;&#x5149;&#x4E92;&#x8054;&#x65B9;&#x6848;</li>
<li><strong>&#x5206;&#x5E03;&#x5F0F;&#x8BA1;&#x7B97;&#x6A21;&#x578B;</strong>&#xFF1A;&#x8BA8;&#x8BBA;&#x4E86;&#x4EFB;&#x52A1;&#x5206;&#x89E3;&#x3001;&#x901A;&#x4FE1;&#x4F18;&#x5316;&#x548C;&#x8D1F;&#x8F7D;&#x5747;&#x8861;&#x7B56;&#x7565;</li>
<li><strong>&#x6570;&#x636E;&#x4E00;&#x81F4;&#x6027;</strong>&#xFF1A;&#x8BE6;&#x7EC6;&#x8BF4;&#x660E;&#x4E86;&#x4E00;&#x81F4;&#x6027;&#x6A21;&#x578B;&#x3001;&#x540C;&#x6B65;&#x539F;&#x8BED;&#x548C;&#x7F13;&#x5B58;&#x534F;&#x8BAE;</li>
<li><strong>Chiplet&#x6280;&#x672F;</strong>&#xFF1A;&#x63A2;&#x8BA8;&#x4E86;&#x591A;die&#x5C01;&#x88C5;&#x3001;&#x4E92;&#x8054;&#x6280;&#x672F;&#x548C;&#x7F16;&#x7A0B;&#x6A21;&#x578B;</li>
<li><strong>&#x6269;&#x5C55;&#x6027;&#x80FD;&#x5EFA;&#x6A21;</strong>&#xFF1A;&#x5EFA;&#x7ACB;&#x4E86;&#x5B8C;&#x6574;&#x7684;&#x6027;&#x80FD;&#x6A21;&#x578B;&#x3001;&#x6269;&#x5C55;&#x6027;&#x5206;&#x6790;&#x548C;&#x4F18;&#x5316;&#x6846;&#x67B6;</li>
</ol>
<p>&#x5173;&#x952E;&#x8981;&#x70B9;&#xFF1A;</p>
<ul>
<li>&#x4E92;&#x8054;&#x5E26;&#x5BBD;&#x548C;&#x5EF6;&#x8FDF;&#x662F;&#x591A;FPGA&#x7CFB;&#x7EDF;&#x7684;&#x4E3B;&#x8981;&#x74F6;&#x9888;</li>
<li>&#x5408;&#x7406;&#x7684;&#x4EFB;&#x52A1;&#x5212;&#x5206;&#x548C;&#x6570;&#x636E;&#x5C40;&#x90E8;&#x6027;&#x4F18;&#x5316;&#x81F3;&#x5173;&#x91CD;&#x8981;</li>
<li>&#x6027;&#x80FD;&#x5EFA;&#x6A21;&#x5E2E;&#x52A9;&#x5728;&#x8BBE;&#x8BA1;&#x65E9;&#x671F;&#x8BC6;&#x522B;&#x6269;&#x5C55;&#x6027;&#x95EE;&#x9898;</li>
<li>Chiplet&#x6280;&#x672F;&#x4EE3;&#x8868;&#x4E86;FPGA&#x96C6;&#x6210;&#x7684;&#x672A;&#x6765;&#x65B9;&#x5411;</li>
</ul>
<h2 id="&#x7EC3;&#x4E60;&#x9898;">&#x7EC3;&#x4E60;&#x9898;</h2>
<ol>
<li><p><strong>&#x4E92;&#x8054;&#x67B6;&#x6784;&#x8BBE;&#x8BA1;&#x9898;</strong>
&#x8BBE;&#x8BA1;&#x4E00;&#x4E2A;16&#x4E2A;FPGA&#x7684;&#x4E92;&#x8054;&#x7F51;&#x7EDC;&#xFF0C;&#x8981;&#x6C42;&#x4EFB;&#x610F;&#x4E24;&#x4E2A;FPGA&#x4E4B;&#x95F4;&#x7684;&#x6700;&#x5927;&#x8DF3;&#x6570;&#x4E0D;&#x8D85;&#x8FC7;3&#x3002;&#x6BD4;&#x8F83;&#x4E0D;&#x540C;&#x62D3;&#x6251;&#x7684;&#x6210;&#x672C;&#x548C;&#x6027;&#x80FD;&#x3002;</p>
<p><em>Hint: &#x8003;&#x8651;2D mesh&#x3001;torus&#x6216;hypercube&#x62D3;&#x6251;</em></p>
</li>
<li><p><strong>&#x5206;&#x5E03;&#x5F0F;&#x7B97;&#x6CD5;&#x5B9E;&#x73B0;&#x9898;</strong>
&#x5B9E;&#x73B0;&#x4E00;&#x4E2A;&#x5206;&#x5E03;&#x5F0F;&#x77E9;&#x9635;&#x4E58;&#x6CD5;&#xFF0C;&#x5C06;1024&#xD7;1024&#x7684;&#x77E9;&#x9635;&#x5206;&#x5E03;&#x5230;8&#x4E2A;FPGA&#x4E0A;&#x8BA1;&#x7B97;&#x3002;&#x5982;&#x4F55;&#x6700;&#x5C0F;&#x5316;&#x901A;&#x4FE1;&#x5F00;&#x9500;&#xFF1F;</p>
<p><em>Hint: &#x8003;&#x8651;Cannon&#x7B97;&#x6CD5;&#x6216;2.5D&#x7B97;&#x6CD5;</em></p>
</li>
<li><p><strong>&#x4E00;&#x81F4;&#x6027;&#x534F;&#x8BAE;&#x8BBE;&#x8BA1;&#x9898;</strong>
&#x8BBE;&#x8BA1;&#x4E00;&#x4E2A;&#x7B80;&#x5316;&#x7684;&#x7F13;&#x5B58;&#x4E00;&#x81F4;&#x6027;&#x534F;&#x8BAE;&#xFF0C;&#x652F;&#x6301;4&#x4E2A;FPGA&#x5171;&#x4EAB;&#x8BBF;&#x95EE;&#x540C;&#x4E00;&#x5757;&#x5185;&#x5B58;&#x533A;&#x57DF;&#x3002;</p>
<p><em>Hint: &#x53EF;&#x4EE5;&#x4ECE;MSI&#x6216;MESI&#x534F;&#x8BAE;&#x7B80;&#x5316;</em></p>
</li>
<li><p><strong>&#x6027;&#x80FD;&#x5EFA;&#x6A21;&#x9898;</strong>
&#x7ED9;&#x5B9A;&#x4E00;&#x4E2A;&#x5E94;&#x7528;&#x6709;30%&#x7684;&#x4E32;&#x884C;&#x90E8;&#x5206;&#xFF0C;&#x5728;&#x5355;FPGA&#x4E0A;&#x8FD0;&#x884C;&#x9700;&#x8981;100&#x79D2;&#x3002;&#x9884;&#x6D4B;&#x5728;16&#x4E2A;FPGA&#x4E0A;&#x7684;&#x6267;&#x884C;&#x65F6;&#x95F4;&#xFF0C;&#x8003;&#x8651;10ms&#x7684;&#x901A;&#x4FE1;&#x5EF6;&#x8FDF;&#x3002;</p>
<p><em>Hint: &#x4F7F;&#x7528;&#x6269;&#x5C55;&#x7684;Amdahl&#x5B9A;&#x5F8B;</em></p>
</li>
<li><p><strong>&#x8D1F;&#x8F7D;&#x5747;&#x8861;&#x7B97;&#x6CD5;&#x9898;</strong>
&#x5B9E;&#x73B0;&#x4E00;&#x4E2A;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;(work-stealing)&#x8C03;&#x5EA6;&#x5668;&#xFF0C;&#x5F53;&#x67D0;&#x4E2A;FPGA&#x7A7A;&#x95F2;&#x65F6;&#x80FD;&#x591F;&#x4ECE;&#x5176;&#x4ED6;FPGA&#x7A83;&#x53D6;&#x4EFB;&#x52A1;&#x3002;</p>
<p><em>Hint: &#x4F7F;&#x7528;&#x5206;&#x5E03;&#x5F0F;&#x961F;&#x5217;&#x548C;&#x539F;&#x5B50;&#x64CD;&#x4F5C;</em></p>
</li>
<li><p><strong>Chiplet&#x4E92;&#x8054;&#x4F18;&#x5316;&#x9898;</strong>
&#x8BBE;&#x8BA1;&#x4E00;&#x4E2A;4-die FPGA&#x7684;NoC&#x8DEF;&#x7531;&#x7B97;&#x6CD5;&#xFF0C;&#x4F18;&#x5316;die&#x95F4;&#x901A;&#x4FE1;&#x5EF6;&#x8FDF;&#x3002;</p>
<p><em>Hint: &#x8003;&#x8651;&#x81EA;&#x9002;&#x5E94;&#x8DEF;&#x7531;&#x548C;&#x865A;&#x62DF;&#x901A;&#x9053;</em></p>
</li>
<li><p><strong>&#x6269;&#x5C55;&#x6027;&#x5206;&#x6790;&#x9898;</strong>
&#x5206;&#x6790;&#x4E00;&#x4E2A;&#x673A;&#x5668;&#x5B66;&#x4E60;&#x63A8;&#x7406;&#x5E94;&#x7528;&#x5728;&#x591A;FPGA&#x7CFB;&#x7EDF;&#x4E0A;&#x7684;&#x5F3A;&#x5F31;&#x6269;&#x5C55;&#x6027;&#xFF0C;&#x786E;&#x5B9A;&#x6700;&#x4F18;FPGA&#x6570;&#x91CF;&#x3002;</p>
<p><em>Hint: &#x6D4B;&#x91CF;&#x4E0D;&#x540C;batch size&#x4E0B;&#x7684;&#x6027;&#x80FD;</em></p>
</li>
<li><p><strong>&#x7CFB;&#x7EDF;&#x96C6;&#x6210;&#x6311;&#x6218;&#x9898;</strong>
&#x8BBE;&#x8BA1;&#x4E00;&#x4E2A;&#x5B8C;&#x6574;&#x7684;8-FPGA&#x96C6;&#x7FA4;&#x7CFB;&#x7EDF;&#xFF0C;&#x5305;&#x62EC;&#x4E92;&#x8054;&#x3001;&#x5B58;&#x50A8;&#x3001;&#x8C03;&#x5EA6;&#x548C;&#x76D1;&#x63A7;&#xFF0C;&#x76EE;&#x6807;&#x662F;&#x89C6;&#x9891;&#x8F6C;&#x7801;&#x52A0;&#x901F;&#x3002;</p>
<p><em>Hint: &#x8003;&#x8651;&#x6570;&#x636E;&#x6D41;&#x3001;&#x8D1F;&#x8F7D;&#x7279;&#x5F81;&#x548C;&#x5BB9;&#x9519;</em></p>
</li>
</ol>
<h2 id="&#x5E38;&#x89C1;&#x9677;&#x9631;&#x4E0E;&#x9519;&#x8BEF;">&#x5E38;&#x89C1;&#x9677;&#x9631;&#x4E0E;&#x9519;&#x8BEF;</h2>
<ol>
<li><p><strong>&#x5FFD;&#x89C6;&#x901A;&#x4FE1;&#x5F00;&#x9500;</strong></p>
<ul>
<li>&#x8FC7;&#x5EA6;&#x7EC6;&#x7C92;&#x5EA6;&#x4EFB;&#x52A1;&#x5212;&#x5206;</li>
<li>&#x5FFD;&#x7565;&#x6570;&#x636E;&#x4F20;&#x8F93;&#x65F6;&#x95F4;</li>
<li>&#x89E3;&#x51B3;&#xFF1A;&#x901A;&#x4FE1;&#x8BA1;&#x7B97;&#x91CD;&#x53E0;&#x3001;&#x6D88;&#x606F;&#x805A;&#x5408;</li>
</ul>
</li>
<li><p><strong>&#x8D1F;&#x8F7D;&#x4E0D;&#x5747;&#x8861;</strong></p>
<ul>
<li>&#x9759;&#x6001;&#x4EFB;&#x52A1;&#x5206;&#x914D;</li>
<li>&#x5FFD;&#x7565;&#x4EFB;&#x52A1;&#x6267;&#x884C;&#x65F6;&#x95F4;&#x5DEE;&#x5F02;</li>
<li>&#x89E3;&#x51B3;&#xFF1A;&#x52A8;&#x6001;&#x8C03;&#x5EA6;&#x3001;&#x5DE5;&#x4F5C;&#x7A83;&#x53D6;</li>
</ul>
</li>
<li><p><strong>&#x540C;&#x6B65;&#x5F00;&#x9500;&#x8FC7;&#x5927;</strong></p>
<ul>
<li>&#x9891;&#x7E41;&#x7684;&#x5168;&#x5C40;&#x540C;&#x6B65;</li>
<li>&#x9501;&#x7ADE;&#x4E89;&#x6FC0;&#x70C8;</li>
<li>&#x89E3;&#x51B3;&#xFF1A;&#x51CF;&#x5C11;&#x540C;&#x6B65;&#x70B9;&#x3001;&#x4F7F;&#x7528;&#x65E0;&#x9501;&#x7B97;&#x6CD5;</li>
</ul>
</li>
<li><p><strong>&#x62D3;&#x6251;&#x4E0D;&#x5339;&#x914D;</strong></p>
<ul>
<li>&#x901A;&#x4FE1;&#x6A21;&#x5F0F;&#x4E0E;&#x7269;&#x7406;&#x62D3;&#x6251;&#x4E0D;&#x5339;&#x914D;</li>
<li>&#x5FFD;&#x7565;&#x5C40;&#x90E8;&#x6027;&#x4F18;&#x5316;</li>
<li>&#x89E3;&#x51B3;&#xFF1A;&#x62D3;&#x6251;&#x611F;&#x77E5;&#x6620;&#x5C04;</li>
</ul>
</li>
<li><p><strong>&#x6269;&#x5C55;&#x6027;&#x9884;&#x671F;&#x8FC7;&#x9AD8;</strong></p>
<ul>
<li>&#x5FFD;&#x7565;Amdahl&#x5B9A;&#x5F8B;&#x9650;&#x5236;</li>
<li>&#x4F4E;&#x4F30;&#x901A;&#x4FE1;&#x5F00;&#x9500;&#x589E;&#x957F;</li>
<li>&#x89E3;&#x51B3;&#xFF1A;realistic&#x5EFA;&#x6A21;&#x548C;&#x6D4B;&#x8BD5;</li>
</ul>
</li>
</ol>
<h2 id="&#x6700;&#x4F73;&#x5B9E;&#x8DF5;&#x68C0;&#x67E5;&#x6E05;&#x5355;">&#x6700;&#x4F73;&#x5B9E;&#x8DF5;&#x68C0;&#x67E5;&#x6E05;&#x5355;</h2>
<h3 id="&#x7CFB;&#x7EDF;&#x67B6;&#x6784;">&#x7CFB;&#x7EDF;&#x67B6;&#x6784;</h3>
<ul>
<li>[ ] &#x9009;&#x62E9;&#x9002;&#x5408;&#x5E94;&#x7528;&#x7684;&#x4E92;&#x8054;&#x62D3;&#x6251;</li>
<li>[ ] &#x9884;&#x7559;&#x8DB3;&#x591F;&#x7684;&#x4E92;&#x8054;&#x5E26;&#x5BBD;</li>
<li>[ ] &#x8003;&#x8651;&#x6545;&#x969C;&#x5BB9;&#x9519;&#x80FD;&#x529B;</li>
<li>[ ] &#x652F;&#x6301;&#x5728;&#x7EBF;&#x6269;&#x5C55;</li>
</ul>
<h3 id="&#x8F6F;&#x4EF6;&#x8BBE;&#x8BA1;">&#x8F6F;&#x4EF6;&#x8BBE;&#x8BA1;</h3>
<ul>
<li>[ ] &#x6700;&#x5C0F;&#x5316;FPGA&#x95F4;&#x901A;&#x4FE1;</li>
<li>[ ] &#x5B9E;&#x73B0;&#x6709;&#x6548;&#x7684;&#x8D1F;&#x8F7D;&#x5747;&#x8861;</li>
<li>[ ] &#x4F7F;&#x7528;&#x5F02;&#x6B65;&#x901A;&#x4FE1;&#x6A21;&#x5F0F;</li>
<li>[ ] &#x4F18;&#x5316;&#x6570;&#x636E;&#x5C40;&#x90E8;&#x6027;</li>
</ul>
<h3 id="&#x6027;&#x80FD;&#x4F18;&#x5316;">&#x6027;&#x80FD;&#x4F18;&#x5316;</h3>
<ul>
<li>[ ] &#x5EFA;&#x7ACB;&#x51C6;&#x786E;&#x7684;&#x6027;&#x80FD;&#x6A21;&#x578B;</li>
<li>[ ] &#x6301;&#x7EED;&#x76D1;&#x63A7;&#x7CFB;&#x7EDF;&#x6027;&#x80FD;</li>
<li>[ ] &#x8BC6;&#x522B;&#x5E76;&#x6D88;&#x9664;&#x74F6;&#x9888;</li>
<li>[ ] &#x5B9A;&#x671F;&#x4F18;&#x5316;&#x901A;&#x4FE1;&#x6A21;&#x5F0F;</li>
</ul>
<h3 id="&#x53EF;&#x9760;&#x6027;">&#x53EF;&#x9760;&#x6027;</h3>
<ul>
<li>[ ] &#x5B9E;&#x73B0;&#x5FC3;&#x8DF3;&#x68C0;&#x6D4B;&#x673A;&#x5236;</li>
<li>[ ] &#x652F;&#x6301;FPGA&#x70ED;&#x63D2;&#x62D4;</li>
<li>[ ] &#x8BBE;&#x8BA1;&#x6545;&#x969C;&#x6062;&#x590D;&#x7B56;&#x7565;</li>
<li>[ ] &#x5B9A;&#x671F;&#x5907;&#x4EFD;&#x5173;&#x952E;&#x72B6;&#x6001;</li>
</ul>
<hr>
<div style="text-align: center; margin: 20px 0;">
  <a href="chapter19.html" style="margin-right: 20px;">&#x2190; &#x4E0A;&#x4E00;&#x7AE0;&#xFF1A;&#x672A;&#x6765;&#x8D8B;&#x52BF;&#x4E0E;&#x65B0;&#x5174;&#x6280;&#x672F;</a>
  <a href="chapter21.html" style="margin-left: 20px;">&#x4E0B;&#x4E00;&#x7AE0;&#xFF1A;&#x53EF;&#x9760;&#x6027;&#x4E0E;&#x5BB9;&#x9519;&#x8BBE;&#x8BA1; &#x2192;</a>
</div>



<script type="text/javascript">var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';}</script>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter19.html" class="navigation navigation-prev " aria-label="Previous page: 第19章：功耗优化技术">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter21.html" class="navigation navigation-next " aria-label="Next page: 第21章：可靠性与容错设计">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第20章：多FPGA系统与扩展","level":"5.3","depth":1,"next":{"title":"第21章：可靠性与容错设计","level":"5.4","depth":1,"path":"chapters/chapter21.md","ref":"chapters/chapter21.md","articles":[]},"previous":{"title":"第19章：功耗优化技术","level":"5.2","depth":1,"path":"chapters/chapter19.md","ref":"chapters/chapter19.md","articles":[]},"dir":"ltr"},"config":{"plugins":["expandable-chapters","search","copy-code-button","theme-default","back-to-top-button","github","splitter","toc"],"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"assets/css/website.css"},"pluginsConfig":{"github":{"url":"https://github.com/Xde1997/Tutorial_FPGA"},"splitter":{},"toc":{"addClass":true,"className":"toc"},"search":{"maxIndexSize":100000,"ignoreCase":true},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"back-to-top-button":{},"copy-code-button":{"copyText":"复制代码","format":"html"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"showLevel":true,"styles":{"ebook":"styles/ebook.css","epub":"styles/epub.css","mobi":"styles/mobi.css","pdf":"styles/pdf.css","print":"styles/print.css","website":"assets/css/website.css"}},"expandable-chapters":{"chapterExpand":true,"chapterRespectURL":true}},"theme":"default","author":"FPGA教程团队","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"themeColor":"#2196F3","themeColorSecondary":"#FF5722"},"title":"FPGA原理与AI加速应用教程","language":"zh-hans","gitbook":"*","description":"面向软件工程师的FPGA实战指南"},"file":{"path":"chapters/chapter20.md","mtime":"2025-08-03T12:50:50.919Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2025-08-03T12:52:22.204Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

